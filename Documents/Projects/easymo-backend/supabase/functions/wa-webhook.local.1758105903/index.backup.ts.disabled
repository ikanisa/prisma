/* =========================
   wa-webhook.ts â€” PART 1/3
   (Copy this, then Iâ€™ll send PART 2/3 and PART 3/3. Concatenate in order.)
   ========================= */

/* deno-lint-ignore-file no-explicit-any */

/**
 * wa-webhook â€” aligned with your previous codebase, plus MoMo QR feature
 * and additive-only enhancements for the 6 gaps (vehicle-first nearby, drop-off,
 * basket deep links, public review, contribution approvals, and basket type fix),
 * cross-cutting helpers, and light RPC extensions.
 *
 * Runtime: Deno (Supabase Edge Function)
 *
 * ENV (same names you already used):
 *   SUPABASE_URL
 *   SUPABASE_SERVICE_ROLE_KEY
 *   WA_TOKEN
 *   WA_PHONE_ID
 *   WA_APP_SECRET
 *   OPENAI_API_KEY
 *   WA_VERIFY_TOKEN   (for GET verification handshake)
 *   (optional) WA_BOT_NUMBER_E164    â†’ used for WhatsApp deeplinks
 */

import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.57.2";

// --------- ENV ----------
const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const WA_TOKEN = Deno.env.get("WA_TOKEN")!;
const WA_PHONE_ID = Deno.env.get("WA_PHONE_ID")!;
const WA_APP_SECRET = Deno.env.get("WA_APP_SECRET") || "";
const OPENAI_API_KEY = Deno.env.get("OPENAI_API_KEY") || "";
const WA_VERIFY_TOKEN = Deno.env.get("WA_VERIFY_TOKEN") || "";

// NEW (additive): public bot number to build deeplinks like https://wa.me/<digits>?text=...
const WA_BOT_NUMBER_E164 = (Deno.env.get("WA_BOT_NUMBER_E164") || "").trim();

// Admins (kept as in your base)
const EXTRA_INSURANCE_ADMINS = ["0250788767816", "0250795588248"];
const BASKET_REVIEW_ADMIN = "+250795588248"; // review notify for public baskets

// --------- Supabase client ----------
const sb = createClient(SUPABASE_URL, SERVICE_KEY);

// --------- WhatsApp helpers ----------
const WA_BASE = `https://graph.facebook.com/v20.0/${WA_PHONE_ID}`;

async function waSend(path: string, payload: any) {
  const res = await fetch(`${WA_BASE}/${path}`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${WA_TOKEN}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(payload),
  });
  if (!res.ok) {
    const errTxt = await res.text();
    throw new Error(`WA send failed: ${res.status} ${errTxt}`);
  }
  return res.json();
}

async function sendText(to: string, body: string) {
  return waSend("messages", {
    messaging_product: "whatsapp",
    to,
    type: "text",
    text: { body },
  });
}

function safeRowTitle(t: string, max = 24) {
  if (!t) return "";
  if (t.length <= max) return t;
  return t.slice(0, max - 1) + "â€¦";
}
function safeRowDesc(t?: string | null, max = 72) {
  const s = (t ?? "").toString();
  if (s.length <= max) return s;
  return s.slice(0, max - 1) + "â€¦";
}
function safeButtonTitle(t: string, max = 20) {
  if (t.length <= max) return t;
  return t.slice(0, max - 1) + "â€¦";
}

async function sendButtons(
  to: string,
  body: string,
  buttons: Array<{ id: string; title: string }>
) {
  return waSend("messages", {
    messaging_product: "whatsapp",
    to,
    type: "interactive",
    interactive: {
      type: "button",
      body: { text: body },
      action: {
        buttons: buttons.slice(0, 3).map((b) => ({
          type: "reply",
          reply: { id: b.id, title: safeButtonTitle(b.title, 20) },
        })),
      },
    },
  });
}

async function sendList(
  to: string,
  opts: {
    title: string;
    body: string;
    sectionTitle: string;
    rows: Array<{ id: string; title: string; description?: string }>;
    buttonText?: string;
  }
) {
  return waSend("messages", {
    messaging_product: "whatsapp",
    to,
    type: "interactive",
    interactive: {
      type: "list",
      header: { type: "text", text: safeRowTitle(opts.title, 60) },
      body: { text: opts.body.slice(0, 1024) },
      footer: { text: "Tip: Reply 'home' anytime." },
      action: {
        button: safeButtonTitle(opts.buttonText || "Choose", 20),
        sections: [
          {
            title: safeRowTitle(opts.sectionTitle, 60),
            rows: opts.rows.slice(0, 10).map((r) => ({
              id: r.id,
              title: safeRowTitle(r.title, 24),
              description: r.description ? safeRowDesc(r.description, 72) : undefined,
            })),
          },
        ],
      },
    },
  });
}

async function sendImageUrl(to: string, link: string, caption?: string) {
  // Uses link-based image sending (no upload to Meta)
  return waSend("messages", {
    messaging_product: "whatsapp",
    to,
    type: "image",
    image: { link, caption },
  });
}

// --------- Signature verification (Meta) ----------
function hexToBytes(h: string) {
  const len = h.length;
  const out = new Uint8Array(len / 2);
  for (let i = 0; i < len; i += 2) out[i / 2] = parseInt(h.slice(i, i + 2), 16);
  return out;
}
function constantTimeEqual(a: Uint8Array, b: Uint8Array) {
  if (a.length !== b.length) return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];
  return diff === 0;
}
async function verifySignature(req: Request, raw: string) {
  if (!WA_APP_SECRET) return true; // dev
  const hdr = req.headers.get("X-Hub-Signature-256") || "";
  if (!hdr.startsWith("sha256=")) return false;
  const providedHex = hdr.slice(7);
  const enc = new TextEncoder();
  const key = await crypto.subtle.importKey(
    "raw",
    enc.encode(WA_APP_SECRET),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"],
  );
  const macBuf = await crypto.subtle.sign("HMAC", key, enc.encode(raw));
  const mac = new Uint8Array(macBuf);
  const provided = hexToBytes(providedHex);
  return constantTimeEqual(mac, provided);
}

// --------- utils ----------
function e164(s: string) {
  s = s.trim();
  if (s.startsWith("+")) return s;
  if (s.startsWith("0250")) return "+250" + s.slice(4);
  if (s.startsWith("250")) return "+250" + s.slice(3);
  if (s.startsWith("0") && s[1] === "7") return "+250" + s.slice(1);
  return s.startsWith("+") ? s : "+" + s;
}
function to07FromE164(e: string) {
  // Convert +2507XXXXXXXX â†’ 07XXXXXXXX (Rwanda)
  const s = e164(e);
  const d = s.replace(/\D/g, "");
  if (d.startsWith("2507")) return "0" + d.slice(3);
  if (d.startsWith("07")) return d;
  return d; // fallback: digits as-is
}
function fmtKm(k?: number | string | null) {
  if (k == null) return "";
  const n = typeof k === "string" ? parseFloat(k) : k;
  if (!isFinite(n)) return "";
  if (n < 1) return `${Math.round(n * 1000)} m`;
  return `${(Math.round(n * 10) / 10).toFixed(1)} km`;
}
function timeAgo(iso?: string | null) {
  if (!iso) return "";
  const d = new Date(iso).getTime();
  const s = Math.max(1, Math.floor((Date.now() - d) / 1000));
  if (s < 60) return `${s}s ago`;
  const m = Math.floor(s / 60);
  if (m < 60) return `${m}m ago`;
  const h = Math.floor(m / 60);
  if (h < 48) return `${h}h ago`;
  return `${Math.floor(h / 24)}d ago`;
}

// --------- profiles / idempotency / state ----------
async function ensureProfile(phone: string) {
  const { data } = await sb
    .from("profiles")
    .select("*")
    .eq("whatsapp_e164", phone)
    .maybeSingle();
  if (data) return data;

  const ins = await sb
    .from("profiles")
    .insert({ whatsapp_e164: phone })
    .select("*")
    .single();
  if (ins.error) throw ins.error;
  return ins.data;
}

async function idempotent(mid: string) {
  const got = await sb
    .from("wa_events")
    .select("wa_message_id")
    .eq("wa_message_id", mid)
    .maybeSingle();
  if (got.data) return false;
  await sb.from("wa_events").insert({ wa_message_id: mid });
  return true;
}

// chat_state.state is stored as { key, data }
type ChatState = { key: string; data?: any };

async function getState(uid: string): Promise<ChatState> {
  const { data } = await sb
    .from("chat_state")
    .select("state")
    .eq("user_id", uid)
    .maybeSingle();

  const raw = (data?.state ?? null) as any;
  if (!raw) return { key: "home", data: {} };
  if (typeof raw === "string") return { key: raw, data: {} };
  if (typeof raw === "object" && raw.key)
    return { key: raw.key, data: raw.data ?? {} };
  return { key: "home", data: {} };
}

async function setState(uid: string, key: string, data: any = {}) {
  await sb.from("chat_state").upsert({
    user_id: uid,
    state: { key, data },
    updated_at: new Date().toISOString(),
  });
}

async function clearState(uid: string) {
  await sb.from("chat_state").delete().eq("user_id", uid);
}

// --------- app config ----------
async function getConfig() {
  const { data } = await sb
    .from("app_config")
    .select("insurance_admin_numbers, momo_qr_logo_url")
    .eq("id", 1)
    .maybeSingle();
  const arr = (data?.insurance_admin_numbers ?? []) as string[];
  const logo = data?.momo_qr_logo_url ?? null;
  return { insurance_admin_numbers: arr, momo_qr_logo_url: logo };
}

// --------- WA media fetch ----------
async function fetchWAMedia(metaId: string) {
  const md = await fetch(`https://graph.facebook.com/v20.0/${metaId}`, {
    headers: { Authorization: `Bearer ${WA_TOKEN}` },
  });
  if (!md.ok) throw new Error(await md.text());
  const j = await md.json();
  const b = await fetch(j.url, { headers: { Authorization: `Bearer ${WA_TOKEN}` } });
  if (!b.ok) throw new Error(await b.text());
  return { bytes: new Uint8Array(await b.arrayBuffer()), mime: j.mime_type as string };
}
function extOf(m: string) {
  if (m.includes("jpeg")) return "jpg";
  if (m.includes("png")) return "png";
  if (m.includes("pdf")) return "pdf";
  return "bin";
}

// --------- OCR (robust JSON only) ----------
async function runInsuranceOCR(url: string) {
  if (!OPENAI_API_KEY) return { extracted: {}, raw: { error: "no OPENAI key" } };

  const body = {
    model: "gpt-4o-mini",
    response_format: { type: "json_object" },
    temperature: 0,
    max_tokens: 600,
    messages: [
      {
        role: "system",
        content:
          "Extract Rwanda motor insurance fields as JSON only. Keys: " +
          "insurer_name, policy_number, certificate_number, policy_inception, policy_expiry, " +
          "carte_jaune_number, carte_jaune_expiry, make, model, vehicle_year, registration_plate, " +
          "vin_chassis, licensed_to_carry.",
      },
      {
        role: "user",
        content: [
          { type: "text", text: "Return ONLY JSON. No commentary." },
          { type: "image_url", image_url: { url } },
        ],
      },
    ],
  };

  try {
    const r = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${OPENAI_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    });

    if (!r.ok) {
      const errTxt = await r.text();
      return { extracted: {}, raw: { error: errTxt } };
    }

    const j = await r.json();
    const content = j?.choices?.[0]?.message?.content ?? "{}";
    let parsed: any = {};
    try {
      parsed = JSON.parse(content);
    } catch {
      parsed = {};
    }

    return { extracted: parsed, raw: j };
  } catch (e) {
    return { extracted: {}, raw: { error: String(e) } };
  }
}

function normIns(e: any) {
  const up = (s: string) => (s ? s.toUpperCase() : s);
  const o: any = { ...e };
  if (o.registration_plate)
    o.registration_plate = up(String(o.registration_plate)).replace(/[^A-Z0-9]/g, "");
  if (o.vin_chassis) o.vin_chassis = up(String(o.vin_chassis)).replace(/[^A-Z0-9]/g, "");
  for (const k of ["policy_inception", "policy_expiry", "carte_jaune_expiry"]) {
    if (o[k]) {
      const d = new Date(o[k]);
      o[k] = isNaN(d.getTime()) ? null : d.toISOString().slice(0, 10);
    }
  }
  if (o.licensed_to_carry != null) {
    const n = parseInt(String(o.licensed_to_carry).replace(/\D/g, ""), 10);
    o.licensed_to_carry = Number.isFinite(n) ? n : null;
  }
  return o;
}
function insUserSummary(e: any) {
  const a = [
    e.make || e.model
      ? `Vehicle: ${e.make ?? ""} ${e.model ?? ""}${e.vehicle_year ? ` (${e.vehicle_year})` : ""}`.trim()
      : "Vehicle: (not detected)",
    e.registration_plate ? `Plate: ${e.registration_plate}` : null,
    e.vin_chassis ? `VIN: ${e.vin_chassis}` : null,
    e.insurer_name ? `Insurer: ${e.insurer_name}` : null,
    e.policy_number ? `Policy #: ${e.policy_number}` : null,
    e.policy_expiry ? `Expiry: ${e.policy_expiry}` : null,
    e.certificate_number ? `Certificate: ${e.certificate_number}` : null,
    e.carte_jaune_number ? `Carte Jaune: ${e.carte_jaune_number}` : null,
  ]
    .filter(Boolean)
    .join("\n");
  return "Thanks! Hereâ€™s what we captured:\n" + a;
}
function insAdminSummary(user: string, e: any) {
  const p = [
    e.make && e.model ? `${e.make} ${e.model}` : null,
    e.registration_plate ? `Plate ${e.registration_plate}` : null,
    e.policy_number ? `Policy ${e.policy_number}` : null,
    e.policy_expiry ? `Exp ${e.policy_expiry}` : null,
  ]
    .filter(Boolean)
    .join(" | ");
  return `New Motor Insurance Lead\nClient: ${user}\n${p}\nChat: https://wa.me/${user.replace(
    "+",
    "",
  )}`;
}

// --------- RPCs (existing) ----------
async function rpcNearbyDrivers(lat: number, lon: number, viewer: string, limit = 10) {
  const { data, error } = await sb.rpc("nearby_drivers", {
    _lat: lat,
    _lon: lon,
    _viewer: viewer,
    _limit: limit,
  });
  if (error) throw error;
  return data as Array<{
    driver_user_id: string;
    whatsapp_e164: string | null;
    distance_km: number;
    last_seen: string;
  }>;
}

async function rpcNearbyPassengers(lat: number, lon: number, viewer: string, limit = 10) {
  const { data, error } = await sb.rpc("nearby_passengers", {
    _lat: lat,
    _lon: lon,
    _viewer: viewer,
    _limit: limit,
  });
  if (error) throw error;
  return data as Array<{
    trip_id: string;
    creator_user_id: string;
    whatsapp_e164: string | null;
    distance_km: number;
    created_at: string;
  }>;
}

async function rpcNearbyBusinesses(lat: number, lon: number, viewer: string, limit = 10) {
  const { data, error } = await sb.rpc("nearby_businesses", {
    _lat: lat,
    _lon: lon,
    _viewer: viewer,
    _limit: limit,
  });
  if (error) throw error;
  return data as Array<{ id: string; name: string; description: string | null; distance_km: number }>;
}

async function rpcMatchDriversForTrip(tripId: string, limit = 10) {
  const { data, error } = await sb.rpc("match_drivers_for_trip", {
    _trip_id: tripId,
    _limit: limit,
  });
  if (error) throw error;
  return data as Array<{ trip_id: string; creator_user_id: string; distance_km: number; created_at: string }>;
}
async function rpcMatchPassengersForTrip(tripId: string, limit = 10) {
  const { data, error } = await sb.rpc("match_passengers_for_trip", {
    _trip_id: tripId,
    _limit: limit,
  });
  if (error) throw error;
  return data as Array<{ trip_id: string; creator_user_id: string; distance_km: number; created_at: string }>;
}

// --------- NEW RPCs (additive) for vehicle-filtered nearby + optional drop-off aware matching ---------
async function rpcNearbyDriversByVehicle(
  lat: number,
  lon: number,
  viewer: string,
  vehicle: string,
  limit = 10,
) {
  // Prefer DB-side RPC if present; otherwise fall back to filtering client-side (additive-safe).
  try {
    const { data, error } = await sb.rpc("nearby_drivers_by_vehicle", {
      _lat: lat,
      _lon: lon,
      _viewer: viewer,
      _vehicle: vehicle,
      _limit: limit,
    });
    if (error) throw error;
    return (data || []) as Array<{
      driver_user_id: string;
      whatsapp_e164: string | null;
      distance_km: number;
      last_seen: string;
      vehicle_type?: string | null;
    }>;
  } catch (_e) {
    // fallback: call generic and filter by profiles.vehicle_type if available
    const base = await rpcNearbyDrivers(lat, lon, viewer, limit * 3);
    if (!base?.length) return [];
    const ids = base.map((r) => r.driver_user_id);
    const meta = ids.length
      ? await sb.from("profiles").select("user_id,meta").in("user_id", ids)
      : { data: [] as any[] };
    const vehMap = new Map<string, string | null>();
    (meta.data || []).forEach((m: any) => {
      const v = (m?.meta?.vehicle_type || m?.meta?.vehicle || null) as string | null;
      vehMap.set(m.user_id, v);
    });
    const want = vehicle.toLowerCase();
    const filtered = base.filter((r) => (vehMap.get(r.driver_user_id) || "").toLowerCase() === want);
    return filtered.slice(0, limit);
  }
}

async function rpcNearbyPassengersByVehicle(
  lat: number,
  lon: number,
  viewer: string,
  vehicle: string,
  limit = 10,
) {
  try {
    const { data, error } = await sb.rpc("nearby_passengers_by_vehicle", {
      _lat: lat,
      _lon: lon,
      _viewer: viewer,
      _vehicle: vehicle,
      _limit: limit,
    });
    if (error) throw error;
    return (data || []) as Array<{
      trip_id: string;
      creator_user_id: string;
      whatsapp_e164: string | null;
      distance_km: number;
      created_at: string;
      vehicle_type?: string | null;
    }>;
  } catch (_e) {
    const base = await rpcNearbyPassengers(lat, lon, viewer, limit * 3);
    if (!base?.length) return [];
    const tripIds = base.map((r) => r.trip_id);
    const trips = tripIds.length
      ? await sb.from("trips").select("id,vehicle_type").in("id", tripIds)
      : { data: [] as any[] };
    const vehMap = new Map<string, string | null>();
    (trips.data || []).forEach((t: any) => vehMap.set(t.id, t.vehicle_type || null));
    const want = vehicle.toLowerCase();
    const filtered = base.filter((r) => (vehMap.get(r.trip_id) || "").toLowerCase() === want);
    return filtered.slice(0, limit);
  }
}

// Extended matchers with optional prefer-dropoff flag (RPCs may accept optional params)
async function rpcMatchDriversForTripEx(tripId: string, limit = 10, preferDrop = true) {
  try {
    const { data, error } = await sb.rpc("match_drivers_for_trip", {
      _trip_id: tripId,
      _limit: limit,
      _prefer_dropoff: preferDrop,
    } as any);
    if (error) throw error;
    return (data || []) as Array<{ trip_id: string; creator_user_id: string; distance_km: number; created_at: string }>;
  } catch (_e) {
    return rpcMatchDriversForTrip(tripId, limit);
  }
}
async function rpcMatchPassengersForTripEx(tripId: string, limit = 10, preferDrop = true) {
  try {
    const { data, error } = await sb.rpc("match_passengers_for_trip", {
      _trip_id: tripId,
      _limit: limit,
      _prefer_dropoff: preferDrop,
    } as any);
    if (error) throw error;
    return (data || []) as Array<{ trip_id: string; creator_user_id: string; distance_km: number; created_at: string }>;
  } catch (_e) {
    return rpcMatchPassengersForTrip(tripId, limit);
  }
}

// --------- Served records (best-effort) ----------
async function markServedDriver(viewerMsisdn: string, driverUserId: string) {
  const expires = new Date(Date.now() + 15 * 60 * 1000).toISOString();
  try {
    await sb.from("served_drivers").insert({
      viewer_passenger_msisdn: viewerMsisdn,
      driver_contact_id: driverUserId,
      expires_at: expires,
      created_at: new Date().toISOString(),
    });
  } catch (e) {
    console.error("served_drivers insert failed", e);
  }
}
async function markServedPassenger(viewerMsisdn: string, tripId: string) {
  const expires = new Date(Date.now() + 15 * 60 * 1000).toISOString();
  try {
    await sb.from("served_passengers").insert({
      viewer_driver_msisdn: viewerMsisdn,
      passenger_trip_id: tripId,
      expires_at: expires,
      created_at: new Date().toISOString(),
    });
  } catch (e) {
    console.error("served_passengers insert failed", e);
  }
}

// --------- UI (Home) ----------
async function sendHome(to: string) {
  await sendList(to, {
    title: "Open menu",
    body: "Welcome ðŸ‘‹\nChoose an option below.",
    sectionTitle: "Menu",
    rows: [
      { id: "see_drivers", title: "Nearby Drivers" },
      { id: "see_passengers", title: "Nearby Passengers" },
      { id: "schedule_trip", title: "Schedule Trip" },
      { id: "marketplace", title: "Marketplace" },
      { id: "baskets", title: "Baskets" },
      { id: "motor_insurance", title: "Motor Insurance" },
      { id: "momoqr_start", title: "MoMo QR Code" }, // NEW
    ],
  });
}

// --------- Basket helpers (unchanged + QR join) ----------
function buildMomoUssd(target: string, isCode: boolean, amount?: number | null) {
  // USSD rules per your plan
  const clean = target.replace(/\D/g, "");
  if (isCode) {
    return amount && amount > 0
      ? `*182*8*1*${clean}*${amount}#`
      : `*182*8*1*${clean}#`;
  } else {
    // number path
    return amount && amount > 0
      ? `*182*1*1*${clean}*${amount}#`
      : `*182*1*1*${clean}#`;
  }
}

async function getBasket(basketId: string) {
  const { data } = await sb.from("baskets").select("*").eq("id", basketId).maybeSingle();
  return data || null;
}

async function isMember(basketId: string, userId: string) {
  const { data } = await sb
    .from("basket_members")
    .select("basket_id")
    .eq("basket_id", basketId)
    .eq("user_id", userId)
    .maybeSingle();
  return !!data;
}

async function addMember(basketId: string, userId: string) {
  try {
    await sb.from("basket_members").upsert({
      basket_id: basketId,
      user_id: userId,
      joined_at: new Date().toISOString(),
      total_contributed: 0,
    });
  } catch (e) {
    console.error("addMember failed", e);
  }
}

async function removeMember(basketId: string, userId: string) {
  try {
    await sb.from("basket_members").delete().eq("basket_id", basketId).eq("user_id", userId);
  } catch (e) {
    console.error("removeMember failed", e);
  }
}

async function listMembersPage(
  basketId: string,
  page: number,
  pageSize: number,
): Promise<Array<{ user_id: string; total_contributed: number; code: string }>> {
  const offset = page * pageSize;
  const { data, error } = await sb
    .from("basket_members")
    .select("user_id,total_contributed")
    .eq("basket_id", basketId)
    .order("total_contributed", { ascending: false })
    .range(offset, offset + pageSize - 1);
  if (error) throw error;

  return (data || []).map((m) => {
    const h = Array.from(new TextEncoder().encode(m.user_id)).reduce((a, c) => (a * 33 + c) >>> 0, 5381);
    const code = String(h % 1000000).padStart(6, "0");
    return { user_id: m.user_id, total_contributed: m.total_contributed ?? 0, code };
  });
}

function basketActionsRows(b: any, isCreator: boolean, isMemberNow: boolean) {
  const rows: Array<{ id: string; title: string; description?: string }> = [
    { id: `bk_det_${b.id}`, title: "View Basket Details" },
    { id: `bk_cont_${b.id}`, title: "Contribute" },
    { id: `bk_share_${b.id}`, title: "Copy Basket Link" },
    { id: `bk_qr_${b.id}`, title: "Basket QR Code" },
    { id: `bk_mems_${b.id}_0`, title: "View Members (page 1)" },
    // NEW (additive) deeplink entries that wonâ€™t break old flows:
    { id: `bkdl_share_${b.id}`, title: "Share Basket (WhatsApp)" },
    { id: `bkdl_qr_${b.id}`, title: "QR to Open (WhatsApp)" },
  ];
  if (!isMemberNow) rows.push({ id: `bk_join_${b.id}`, title: "Join Basket" });
  if (isMemberNow && !isCreator) rows.push({ id: `bk_leave_${b.id}`, title: "Leave Basket" });
  if (isCreator) rows.push({ id: `bk_close_${b.id}`, title: "Close Basket" });
  return rows;
}

function basketDetailsText(b: any) {
  const momo = b.momo_target
    ? (b.momo_is_code ? `MoMo Code: ${b.momo_target}` : `MoMo Number: ${b.momo_target}`)
    : "No MoMo set";
  return [
    `Name: ${b.name}`,
    b.description ? `About: ${b.description}` : undefined,
    `Type: ${b.type}`,
    `Status: ${b.status}`,
    momo,
    b.public_slug ? `Join token: JOIN_BASKET:${b.public_slug}` : `Basket ID: ${b.id}`,
  ].filter(Boolean).join("\n");
}

function qrUrlForJoin(slugOrId: string) {
  const text = `JOIN_BASKET:${slugOrId}`;
  const encoded = encodeURIComponent(text);
  return `https://quickchart.io/qr?text=${encoded}&margin=1&size=512`;
}

// --------- MoMo QR: helpers & logging ----------
function normalizeMoMoNumberInput(s: string): string | null {
  const digits = s.replace(/\D/g, "");
  // Accept 07â€¦, +2507â€¦, 2507â€¦ â†’ normalize to 07XXXXXXXX
  if (digits.startsWith("2507") && digits.length >= 11) return "0" + digits.slice(3);
  if (digits.startsWith("07") && digits.length >= 10) return digits.slice(0, 10);
  if (digits.startsWith("7") && digits.length >= 9) return "0" + digits.slice(0, 9);
  return null;
}
function normalizeMoMoCodeInput(s: string): string | null {
  const d = s.replace(/\D/g, "");
  if (d.length >= 4 && d.length <= 9) return d;
  return null;
}
function buildUssdFor(kind: "number" | "code", value: string, amount?: number | null) {
  const digits = value.replace(/\D/g, "");
  const ussd = buildMomoUssd(digits, kind === "code", amount ?? undefined);
  const tel = `tel:${ussd}`;
  return { ussd, tel };
}
function qrUrlForUssdTel(telUri: string, size = 768) {
  return `https://quickchart.io/qr?text=${encodeURIComponent(telUri)}&margin=1&size=${size}`;
}

async function logMomoQrRequest(params: {
  user_id: string;
  whatsapp_e164: string;
  kind: "number" | "code";
  momo_value: string;
  amount_rwf?: number | null;
  ussd_text: string;
  tel_uri: string;
  qr_url: string;
  share_url?: string | null;
}) {
  try {
    await sb.from("momo_qr_requests").insert({
      user_id: params.user_id,
      whatsapp_e164: params.whatsapp_e164,
      kind: params.kind,
      momo_value: params.momo_value,
      amount_rwf: params.amount_rwf ?? null,
      ussd_text: params.ussd_text,
      tel_uri: params.tel_uri,
      qr_url: params.qr_url,
      share_url: params.share_url ?? null,
      created_at: new Date().toISOString(),
    });
  } catch (e) {
    console.error("momo_qr_requests insert failed", e);
  }
}

// --------- NEW: Basket deep link helpers (additive) ----------
function toWaDigits(e164Num: string) {
  const d = e164(e164Num).replace(/\D/g, "");
  // For wa.me, do not include leading +
  return d;
}
function basketDeepLink(token: string): string {
  // If WA_BOT_NUMBER_E164 not configured, fallback to plain JOIN_BASKET token URL for robustness
  if (!WA_BOT_NUMBER_E164) {
    // Fallback to generic wa.me without a phone (not ideal), but still return encoded text param.
    const txt = encodeURIComponent(`JOIN_BASKET:${token}`);
    return `https://wa.me/?text=${txt}`;
  }
  const digits = toWaDigits(WA_BOT_NUMBER_E164);
  const txt = encodeURIComponent(`JOIN_BASKET:${token}`);
  return `https://wa.me/${digits}?text=${txt}`;
}
function qrUrlForDeepLink(url: string, size = 512) {
  return `https://quickchart.io/qr?text=${encodeURIComponent(url)}&margin=1&size=${size}`;
}

// --------- NEW: Contributions table helpers (additive) ----------
type ContributionRow = {
  id: string;
  basket_id: string;
  contributor_user_id: string;
  amount_rwf: number;
  status: "pending" | "approved" | "rejected";
  created_at: string;
  approved_at?: string | null;
  approver_user_id?: string | null;
};

async function createPendingContribution(basket_id: string, contributor_user_id: string, amount_rwf: number) {
  const ins = await sb
    .from("basket_contributions")
    .insert({
      basket_id,
      contributor_user_id,
      amount_rwf,
      status: "pending",
      created_at: new Date().toISOString(),
    })
    .select("*")
    .single();
  if (ins.error) throw ins.error;
  return ins.data as ContributionRow;
}
async function approveContribution(contribId: string, approver_user_id: string) {
  const now = new Date().toISOString();
  const upd = await sb
    .from("basket_contributions")
    .update({ status: "approved", approved_at: now, approver_user_id })
    .eq("id", contribId)
    .select("*")
    .single();
  if (upd.error) throw upd.error;
  return upd.data as ContributionRow;
}
async function rejectContribution(contribId: string, approver_user_id: string) {
  const upd = await sb
    .from("basket_contributions")
    .update({ status: "rejected", approver_user_id })
    .eq("id", contribId)
    .select("*")
    .single();
  if (upd.error) throw upd.error;
  return upd.data as ContributionRow;
}
async function getContribution(contribId: string) {
  const { data } = await sb
    .from("basket_contributions")
    .select("*")
    .eq("id", contribId)
    .maybeSingle();
  return (data || null) as ContributionRow | null;
}

// Keep basket_members totals in sync after approval (additive)
async function bumpMemberTotal(basketId: string, userId: string, amount: number) {
  const { data: row } = await sb
    .from("basket_members")
    .select("total_contributed")
    .eq("basket_id", basketId)
    .eq("user_id", userId)
    .maybeSingle();
  const prev = Number(row?.total_contributed ?? 0);
  await sb.from("basket_members").upsert({
    basket_id: basketId,
    user_id: userId,
    total_contributed: prev + amount,
    joined_at: new Date().toISOString(),
  });
}

// --------- NEW: Public review admin helpers (additive) ----------
async function sendPublicReviewCardToAdmin(b: any, creatorWaE164: string) {
  try {
    // First: keep your legacy text (safe & backward-compatible)
    const summary = `Basket pending review:
Name: ${b.name}
Type: Public
Creator: ${creatorWaE164}
Slug: ${b.public_slug ?? "(none)"}`;
    await sendText(e164(BASKET_REVIEW_ADMIN), summary);

    // Then: an interactive "review" card with buttons
    const digits = e164(creatorWaE164).replace(/\D/g, "");
    await sendButtons(e164(BASKET_REVIEW_ADMIN), "Basket review", [
      { id: `pubrev_appr_${b.id}`, title: "Approve" },
      { id: `pubrev_chat_${digits}`, title: "Chat creator" },
      { id: `pubrev_view_${b.id}`, title: "View basket" },
    ]);
  } catch (e) {
    console.error("sendPublicReviewCardToAdmin failed", e);
  }
}

async function notifyCreatorApproved(creatorWaE164: string, b: any) {
  try {
    await sendText(creatorWaE164, "âœ… Basket approved! Share it or get the QR below.");
    await sendButtons(creatorWaE164, "Choose an option:", [
      { id: `bkdl_share_${b.id}`, title: "Share Basket (WhatsApp)" },
      { id: `bkdl_qr_${b.id}`, title: "QR to Open (WhatsApp)" },
    ]);
  } catch (e) {
    console.error("notifyCreatorApproved failed", e);
  }
}

// --------- NEW: Schedule drop-off helpers (additive) ----------
async function updateTripDropoff(tripId: string, lon: number, lat: number) {
  try {
    await sb.from("trips").update({ dropoff: `SRID=4326;POINT(${lon} ${lat})` }).eq("id", tripId);
  } catch (e) {
    console.error("updateTripDropoff failed", e);
  }
}

// --------- Handler (BEGIN) ---------
serve(async (req) => {
  // GET: Meta verification
  if (req.method === "GET") {
    const u = new URL(req.url);
    if (
      u.searchParams.get("hub.mode") === "subscribe" &&
      u.searchParams.get("hub.verify_token") === WA_VERIFY_TOKEN
    ) {
      return new Response(u.searchParams.get("hub.challenge") || "", { status: 200 });
    }
    return new Response("OK");
  }

  // POST: inbound
  const raw = await req.text();
  if (!(await verifySignature(req, raw))) return new Response("Bad sig", { status: 401 });

  let payload: any;
  try {
    payload = JSON.parse(raw);
  } catch {
    return new Response("ok");
  }

  const msg = payload?.entry?.[0]?.changes?.[0]?.value?.messages?.[0];
  if (!msg) return new Response("ok");
  if (!(await idempotent(msg.id))) return new Response("dup");

  const from = e164(msg.from?.startsWith("+") ? msg.from : `+${msg.from}`);
  const profile = await ensureProfile(from);
  const user_id: string = profile.user_id;

  // -------- STOP/START + last inbound --------
  const txtBody = (msg.text?.body || "").trim();
  try {
    if (msg.type === "text") {
      if (/^\s*(stop|unsubscribe)\s*$/i.test(txtBody)) {
        await sb.from("contacts").upsert({
          msisdn_e164: from,
          opted_out: true,
          opt_out_ts: new Date().toISOString(),
        }, { onConflict: "msisdn_e164" });
        await sendText(from, "Youâ€™re opted out. Reply START to opt back in.");
        return new Response("ok");
      }
      if (/^\s*start\s*$/i.test(txtBody)) {
        await sb.from("contacts").upsert({
          msisdn_e164: from,
          opted_out: false,
          opted_in: true,
          opt_in_ts: new Date().toISOString(),
        }, { onConflict: "msisdn_e164" });
        await sendText(from, "Youâ€™re opted in. Thanks!");
      }
      await sb.from("contacts").upsert({
        msisdn_e164: from,
        attributes: { last_inbound_ts: new Date().toISOString() },
      }, { onConflict: "msisdn_e164" });
    }
  } catch (_e) {
    // ignore if contacts table not present
  }

  // Load state
  const st = await getState(user_id);
  let state = st.key;
  let data = st.data || {};

  // Global "home/menu"
  const txtLow = txtBody.toLowerCase();
  if (txtLow === "home" || txtLow === "menu") {
    await clearState(user_id);
    await sendHome(from);
    return new Response("ok");
  }

  // Back to menu button
  if (msg.interactive?.type === "button_reply" && msg.interactive.button_reply.id === "back_home") {
    await clearState(user_id);
    await sendHome(from);
    return new Response("ok");
  }

  // ============ NEW: Early intercepts for vehicle-first Nearby (additive) ============
  if (msg.interactive?.type === "list_reply") {
    const id = msg.interactive.list_reply.id || "";

    // When user taps see_drivers / see_passengers, we will show a vehicle chooser first.
    if (id === "see_drivers") {
      // override the old flow additively: present vehicle list first
      await setState(user_id, "near_await_vehicle_choice", { mode: "drivers" });
      await sendList(from, {
        title: "Nearby Drivers",
        body: "Which vehicle type do you want to see nearby?",
        sectionTitle: "Vehicle",
        rows: [
          { id: "near_v_drv_moto", title: "Moto" },
          { id: "near_v_drv_cab", title: "Cab" },
          { id: "near_v_drv_lifan", title: "Lifan" },
          { id: "near_v_drv_truck", title: "Truck" },
          { id: "near_v_drv_others", title: "Others" },
        ],
      });
      return new Response("ok");
    }
    if (id === "see_passengers") {
      await setState(user_id, "near_await_vehicle_choice", { mode: "passengers" });
      await sendList(from, {
        title: "Nearby Passengers",
        body: "Which vehicle type do you want to see nearby?",
        sectionTitle: "Vehicle",
        rows: [
          { id: "near_v_pax_moto", title: "Moto" },
          { id: "near_v_pax_cab", title: "Cab" },
          { id: "near_v_pax_lifan", title: "Lifan" },
          { id: "near_v_pax_truck", title: "Truck" },
          { id: "near_v_pax_others", title: "Others" },
        ],
      });
      return new Response("ok");
    }

    // Vehicle choice rows â†’ set state to near_await_loc_* and ask for location
    const nearDrvPrefix = /^near_v_drv_(moto|cab|lifan|truck|others)$/;
    const nearPaxPrefix = /^near_v_pax_(moto|cab|lifan|truck|others)$/;
    if (nearDrvPrefix.test(id)) {
      const vehicle_type = id.replace("near_v_drv_", "");
      await setState(user_id, "near_await_loc_drivers", { vehicle_type });
      await sendButtons(
        from,
        "Share your current location to see nearby drivers.\n\nTap âž• and share your current location.",
        [{ id: "back_home", title: "Back to Menu" }],
      );
      return new Response("ok");
    }
    if (nearPaxPrefix.test(id)) {
      const vehicle_type = id.replace("near_v_pax_", "");
      await setState(user_id, "near_await_loc_passengers", { vehicle_type });
      await sendButtons(
        from,
        "Share your current location to see nearby passengers.\n\nTap âž• and share your current location.",
        [{ id: "back_home", title: "Back to Menu" }],
      );
      return new Response("ok");
    }

    // ============ NEW: Early intercepts for Basket Type (fix wrong â€œBasket not availableâ€) ============
    if (id === "bk_type_public") {
      const prev = await getState(user_id);
      const name = prev?.data?.name ?? data?.name ?? "(untitled)";
      const description = prev?.data?.description ?? data?.description ?? "";
      await setState(user_id, "await_basket_momo", { name, description, type: "public" });
      await sendButtons(from, "Send MoMo Number (07â€¦) or MoMo Code (4â€“9 digits).", [
        { id: "back_home", title: "Back to Menu" },
      ]);
      return new Response("ok");
    }
    if (id === "bk_type_private") {
      const prev = await getState(user_id);
      const name = prev?.data?.name ?? data?.name ?? "(untitled)";
      const description = prev?.data?.description ?? data?.description ?? "";
      await setState(user_id, "await_basket_momo", { name, description, type: "private" });
      await sendButtons(from, "Send MoMo Number (07â€¦) or MoMo Code (4â€“9 digits).", [
        { id: "back_home", title: "Back to Menu" },
      ]);
      return new Response("ok");
    }

    // ============ NEW: Deep Link / QR actions in basket menu (bkdl_*) ============
    if (id.startsWith("bkdl_")) {
      // These actions are additive and donâ€™t replace the legacy "bk_share_" and "bk_qr_" handlers.
      const parts = id.split("_");
      const action = parts[1]; // share | qr
      const basketId = parts[2];
      const b = await getBasket(basketId);
      if (!b) {
        await sendButtons(from, "Basket not available.", [{ id: "back_home", title: "Back to Menu" }]);
        return new Response("ok");
      }
      const token = b.public_slug || b.id;
      const deeplink = basketDeepLink(token);
      if (action === "share") {
        await sendButtons(from, `Share this WhatsApp link:\n${deeplink}\nAnyone opening it will get basket options right away.`, [
          { id: "back_home", title: "Back to Menu" },
        ]);
        return new Response("ok");
      }
      if (action === "qr") {
        const url = qrUrlForDeepLink(deeplink, 768);
        await sendImageUrl(from, url, `Scan to open basket: ${b.name}`);
        return new Response("ok");
      }
      // If action is unknown, ignore safely.
    }
  }

  // -------- Global: Basket Approve/Reject (legacy) + NEW contrib/pubreview handlers --------
  if (msg.interactive?.type === "button_reply") {
    const bid = msg.interactive.button_reply.id || "";

    // (legacy) bk_appr_ / bk_rej_ remain intact for existing flow.
    if (bid.startsWith("bk_appr_") || bid.startsWith("bk_rej_")) {
      const parts = bid.split("_");
      const action = parts[1]; // appr or rej
      const basketId = parts[2];
      const memberId = parts[3];
      const amountCents = parseInt(parts[4] || "0", 10);
      const amountRwf = Math.floor(amountCents / 100);

      if (!basketId || !memberId || !Number.isFinite(amountCents)) {
        await sendButtons(from, "Invalid action button.", [{ id: "back_home", title: "Back to Menu" }]);
        return new Response("ok");
      }

      if (action === "appr") {
        try {
          const { data: row } = await sb
            .from("basket_members")
            .select("total_contributed")
            .eq("basket_id", basketId)
            .eq("user_id", memberId)
            .maybeSingle();
          const prev = row?.total_contributed ?? 0;
          await sb
            .from("basket_members")
            .upsert({
              basket_id: basketId,
              user_id: memberId,
              total_contributed: Number(prev) + amountRwf,
              joined_at: new Date().toISOString(),
            });

          const { data: prof } = await sb
            .from("profiles")
            .select("whatsapp_e164")
            .eq("user_id", memberId)
            .maybeSingle();
          const memberWa = prof?.whatsapp_e164;
          if (memberWa) {
            await sendText(memberWa, `âœ… Contribution approved: RWF ${amountRwf.toLocaleString()}. Thank you!`);
          }
          await sendButtons(from, "Approved and member notified.", [{ id: "back_home", title: "Back to Menu" }]);
        } catch (e) {
          console.error("approve error", e);
          await sendButtons(from, "Couldnâ€™t approve. Try again.", [{ id: "back_home", title: "Back to Menu" }]);
        }
        return new Response("ok");
      }

      if (action === "rej") {
        try {
          const { data: prof } = await sb
            .from("profiles")
            .select("whatsapp_e164")
            .eq("user_id", memberId)
            .maybeSingle();
          const memberWa = prof?.whatsapp_e164;
          if (memberWa) {
            await sendText(memberWa, `âŒ Contribution rejected by the basket creator.`);
          }
          await sendButtons(from, "Rejected and member notified.", [{ id: "back_home", title: "Back to Menu" }]);
        } catch (e) {
          console.error("reject error", e);
          await sendButtons(from, "Couldnâ€™t reject. Try again.", [{ id: "back_home", title: "Back to Menu" }]);
        }
        return new Response("ok");
      }
    }

    // NEW: Public review admin actions
    if (bid.startsWith("pubrev_")) {
      const parts = bid.split("_");
      const action = parts[1]; // appr | chat | view
      const ref = parts[2];
      try {
        if (action === "appr") {
          const basketId = ref;
          await sb.from("baskets").update({ status: "approved" }).eq("id", basketId);
          const b = await getBasket(basketId);
          if (b) {
            const { data: prof } = await sb.from("profiles").select("whatsapp_e164").eq("user_id", b.creator_id).maybeSingle();
            const creatorWa = prof?.whatsapp_e164;
            if (creatorWa) await notifyCreatorApproved(creatorWa, b);
          }
          await sendButtons(from, "âœ… Basket approved.", [{ id: "back_home", title: "Back to Menu" }]);
          return new Response("ok");
        }
        if (action === "chat") {
          // ref is creator digits
          const digits = ref.replace(/\D/g, "");
          await sendButtons(from, `Tap to chat with creator:\nhttps://wa.me/${digits}`, [
            { id: "back_home", title: "Back to Menu" },
          ]);
          return new Response("ok");
        }
        if (action === "view") {
          const basketId = ref;
          const b = await getBasket(basketId);
          if (!b) {
            await sendButtons(from, "Basket not available.", [{ id: "back_home", title: "Back to Menu" }]);
            return new Response("ok");
          }
          const token = b.public_slug || b.id;
          const deeplink = basketDeepLink(token);
          await sendButtons(from, `Basket link:\n${deeplink}`, [{ id: "back_home", title: "Back to Menu" }]);
          return new Response("ok");
        }
      } catch (e) {
        console.error("pubrev handler failed", e);
        await sendButtons(from, "Action failed.", [{ id: "back_home", title: "Back to Menu" }]);
      }
      return new Response("ok");
    }

    // NEW: Contribution review buttons to creator
    if (bid.startsWith("contrib_")) {
      const parts = bid.split("_");
      const action = parts[1]; // appr | rej | chat
      const ref = parts[2];
      try {
        if (action === "appr") {
          const contribId = ref;
          const row = await approveContribution(contribId, user_id);
          // update totals
          await bumpMemberTotal(row.basket_id, row.contributor_user_id, row.amount_rwf);
          const { data: prof } = await sb
            .from("profiles")
            .select("whatsapp_e164")
            .eq("user_id", row.contributor_user_id)
            .maybeSingle();
          if (prof?.whatsapp_e164) {
            await sendText(prof.whatsapp_e164, `âœ… Contribution approved: RWF ${row.amount_rwf.toLocaleString()}. Thank you!`);
          }
          await sendButtons(from, "Approved & contributor notified.", [{ id: "back_home", title: "Back to Menu" }]);
          return new Response("ok");
        }
        if (action === "rej") {
          const contribId = ref;
          const row = await rejectContribution(contribId, user_id);
          const { data: prof } = await sb
            .from("profiles")
            .select("whatsapp_e164")
            .eq("user_id", row.contributor_user_id)
            .maybeSingle();
          if (prof?.whatsapp_e164) {
            await sendText(prof.whatsapp_e164, `âŒ Contribution rejected by the basket creator.`);
          }
          await sendButtons(from, "Rejected & contributor notified.", [{ id: "back_home", title: "Back to Menu" }]);
          return new Response("ok");
        }
        if (action === "chat") {
          const contributorDigits = ref.replace(/\D/g, "");
          await sendButtons(from, `Tap to chat:\nhttps://wa.me/${contributorDigits}`, [{ id: "back_home", title: "Back to Menu" }]);
          return new Response("ok");
        }
      } catch (e) {
        console.error("contrib handler failed", e);
        await sendButtons(from, "Action failed.", [{ id: "back_home", title: "Back to Menu" }]);
      }
      return new Response("ok");
    }
  }

/* =========================
   >>> PART 2/3 will continue from here (keep this file open).
   It will include:
   - List replies (existing + additive paths)
   - Text inputs (existing + additive paths, including creating pending contribution with interactive buttons)
   - Button replies (existing + additive, including post-create CTAs for public/private)
   - Location handling (existing + additive: new near_await_loc_* and sched_await_drop)
   - Row-click handlers (existing + bkdl_ already added above)
   - Insurance media (unchanged)
   - Final fallback
   - generateAndSendMomoQR (existing)
   - NEW helper to send contribution review card
   ========================= */
/* =========================
   wa-webhook.ts â€” PART 2/3
   (Append this immediately after PART 1/3. Donâ€™t remove anything.)
   ========================= */

/* deno-lint-ignore-file no-explicit-any */

// ------------------ CONTINUATION: LIST REPLIES (existing + additive) ------------------
if (msg.interactive?.type === "list_reply") {
  const id = msg.interactive.list_reply.id || "";

  // ----- Schedule Trip (existing path) -----
  if (id === "schedule_trip") {
    await setState(user_id, "await_schedule_role");
    await sendList(from, {
      title: "Schedule Trip",
      body: "Choose your role.",
      sectionTitle: "Role",
      rows: [
        { id: "role_passenger", title: "Passenger" },
        { id: "role_driver", title: "Driver" },
      ],
    });
    return new Response("ok");
  }

  if (id === "marketplace") {
    await setState(user_id, "await_market_option");
    await sendList(from, {
      title: "Marketplace",
      body: "Choose an option.",
      sectionTitle: "Marketplace",
      rows: [
        { id: "mk_add", title: "Add Business" },
        { id: "mk_see", title: "See Businesses" },
      ],
    });
    return new Response("ok");
  }

  if (id === "baskets") {
    await setState(user_id, "await_baskets_action");
    await sendList(from, {
      title: "Baskets",
      body: "Choose an option.",
      sectionTitle: "Baskets",
      rows: [
        { id: "bk_view", title: "View Baskets" },
        { id: "bk_create", title: "Create Basket" },
        { id: "bk_help", title: "Help" },
      ],
    });
    return new Response("ok");
  }

  if (id === "motor_insurance") {
    await setState(user_id, "ins_wait_doc");
    await sendButtons(
      from,
      "Send a photo or PDF of your insurance certificate or yellow vehicle card (one file only).\n\nTap âž• and upload your file.",
      [{ id: "back_home", title: "Back to Menu" }],
    );
    return new Response("ok");
  }

  // ----- Role -> Vehicle (existing path; kept) -----
  if (id === "role_passenger" || id === "role_driver") {
    const role = id === "role_passenger" ? "passenger" : "driver";
    await setState(user_id, "await_schedule_vehicle", { role });
    await sendList(from, {
      title: "Vehicle Type",
      body: "Choose your vehicle type.",
      sectionTitle: "Vehicle",
      rows: [
        { id: "veh_moto", title: "Moto" },
        { id: "veh_cab", title: "Cab" },
        { id: "veh_lifan", title: "Lifan" },
        { id: "veh_truck", title: "Truck" },
        { id: "veh_others", title: "Others" },
      ],
    });
    return new Response("ok");
  }

  // ----- Marketplace category selection (existing path; kept) -----
  if (id === "mk_add") {
    const { data: cats } = await sb
      .from("marketplace_categories")
      .select("id,name,sort_order,is_active")
      .eq("is_active", true)
      .order("sort_order", { ascending: true })
      .order("name", { ascending: true });

    const rows = (cats || [])
      .slice(0, 10)
      .map((c) => ({
        id: `cat_${c.id}`,
        title: safeRowTitle(c.name, 24),
      }));

    await setState(user_id, "await_market_category");
    await sendList(from, {
      title: "Add Business",
      body: "Choose a category.",
      sectionTitle: "Categories",
      rows: rows.length ? rows : [{ id: "back_home", title: "No categories" }],
    });
    return new Response("ok");
  }
  if (id === "mk_see") {
    const { data: cats } = await sb
      .from("marketplace_categories")
      .select("id,name,sort_order,is_active")
      .eq("is_active", true)
      .order("sort_order", { ascending: true })
      .order("name", { ascending: true });

    const rows = (cats || [])
      .slice(0, 10)
      .map((c) => ({
        id: `see_cat_${c.id}`,
        title: safeRowTitle(c.name, 24),
      }));

    await setState(user_id, "await_market_see_category");
    await sendList(from, {
      title: "See Businesses",
      body: "Choose a category.",
      sectionTitle: "Categories",
      rows: rows.length ? rows : [{ id: "back_home", title: "No categories" }],
    });
    return new Response("ok");
  }

  if (id.startsWith("cat_")) {
    const category_id = Number(id.split("_")[1]);
    await setState(user_id, "await_business_name", { category_id });
    await sendButtons(from, "Enter your business name (send it as text).", [
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }

  if (id.startsWith("see_cat_")) {
    const category_id = Number(id.split("_")[2]);
    await setState(user_id, "await_market_see_loc", { category_id });
    await sendButtons(
      from,
      "Share your location to find nearby businesses.\n\nTap âž• and share your current location.",
      [{ id: "back_home", title: "Back to Menu" }],
    );
    return new Response("ok");
  }

  // ----- Vehicle choice for scheduling (existing path; kept) -----
  if (id.startsWith("veh_") && state === "await_schedule_vehicle") {
    const role = data.role;
    const vehicle_type = id.replace("veh_", "");
    await setState(user_id, "await_schedule_pickup", { role, vehicle_type });
    await sendButtons(from, "Share your pickup location.\n\nTap âž• and share your current location.", [
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }

  // ----- Baskets index (existing path; kept) -----
  if (id === "bk_view") {
    const mineIds: string[] = [];
    const created = await sb
      .from("baskets")
      .select("id,name,created_at")
      .eq("creator_id", user_id)
      .order("created_at", { ascending: false })
      .limit(10);
    (created.data || []).forEach((b) => mineIds.push(b.id));

    const memberOf = await sb
      .from("basket_members")
      .select("basket_id")
      .eq("user_id", user_id)
      .limit(50);
    (memberOf.data || []).forEach((m) => {
      if (!mineIds.includes(m.basket_id)) mineIds.push(m.basket_id);
    });

    let rows: Array<{ id: string; title: string; description?: string }> = [];
    if (mineIds.length) {
      const { data: bs } = await sb
        .from("baskets")
        .select("id,name,type,status,created_at")
        .in("id", mineIds)
        .order("created_at", { ascending: false })
        .limit(10);
      rows = (bs || []).map((b) => ({
        id: `b_${b.id}`,
        title: safeRowTitle(b.name, 24),
        description: `${b.type}/${b.status}`,
      }));
    } else {
      const pub = await sb
        .from("baskets")
        .select("id,name,description,created_at")
        .eq("type", "public")
        .eq("status", "approved")
        .order("created_at", { ascending: false })
        .limit(10);
      rows = (pub.data || []).map((b) => ({ id: `b_${b.id}`, title: safeRowTitle(b.name, 24), description: "Public" }));
    }

    if (!rows.length) {
      await sendButtons(from, "No baskets yet.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }

    await sendList(from, {
      title: "Baskets",
      body: "Pick a basket.",
      sectionTitle: "Baskets",
      rows,
    });
    return new Response("ok");
  }

  if (id === "bk_create") {
    await setState(user_id, "await_basket_name");
    await sendButtons(from, "Whatâ€™s the basket name?", [{ id: "back_home", title: "Back to Menu" }]);
    return new Response("ok");
  }

  if (id === "bk_help") {
    await sendButtons(from, "Chat with support:\nhttps://wa.me/35677186193", [
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }

  // ----- Businesses â†’ actions (existing path; kept via row-click later) -----
}

// ------------------ CONTINUATION: TEXT INPUTS (existing + additive) ------------------
if (msg.type === "text" && msg.text?.body) {
  const body = msg.text.body.trim();

  // Global JOIN_BASKET already handled in PART 1 (kept).

  // Add Business flow (existing path; kept)
  if (state === "await_business_name") {
    await setState(user_id, "await_business_desc", { ...data, name: body });
    await sendButtons(from, "Add a short description (one line).", [
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }

  if (state === "await_business_desc") {
    await setState(user_id, "await_business_catalog", { ...data, description: body });
    await sendButtons(
      from,
      "Paste your WhatsApp catalog link (httpâ€¦) or tap Skip.",
      [
        { id: "biz_catalog_skip", title: "Skip" },
        { id: "back_home", title: "Back to Menu" },
      ],
    );
    return new Response("ok");
  }

  if (state === "await_business_catalog") {
    const catalog_url = body.startsWith("http://") || body.startsWith("https://") ? body : null;
    await setState(user_id, "await_business_location", { ...data, catalog_url });
    await sendButtons(
      from,
      "Share your business location.\n\nTap âž• and share your current location.",
      [{ id: "back_home", title: "Back to Menu" }],
    );
    return new Response("ok");
  }

  // Baskets create (existing flow; we add bk_type intercepts elsewhere)
  if (state === "await_basket_name") {
    await setState(user_id, "await_basket_desc", { name: body });
    await sendButtons(from, "Add a short description (â‰¤ 256 chars).", [
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }

  if (state === "await_basket_desc") {
    await setState(user_id, "await_basket_type", { ...data, description: body });
    await sendList(from, {
      title: "Basket Type",
      body: "Choose basket type.",
      sectionTitle: "Type",
      rows: [
        { id: "bk_type_public", title: "Public" },
        { id: "bk_type_private", title: "Private" },
      ],
    });
    return new Response("ok");
  }

  // After type, ask MoMo number/code â€” handled in PART 1 intercept for await_basket_momo.
  if (state === "await_basket_momo") {
    const rawNumOrCode = body.replace(/\s+/g, "");
    let momo_is_code = false;
    let momo_target = "";

    if (/^\d{4,9}$/.test(rawNumOrCode)) {
      momo_is_code = true;
      momo_target = rawNumOrCode;
    } else {
      const normalized = normalizeMoMoNumberInput(rawNumOrCode);
      if (normalized) {
        momo_is_code = false;
        momo_target = normalized;
      } else {
        await sendButtons(from, "Invalid MoMo. Send a 07â€¦ number or a 4â€“9 digit code.", [
          { id: "back_home", title: "Back to Menu" },
        ]);
        return new Response("ok");
      }
    }

    await setState(user_id, "await_basket_confirm", { ...data, momo_target, momo_is_code });
    await sendButtons(
      from,
      `Saved.\n${momo_is_code ? "MoMo Code" : "MoMo Number"}: ${momo_target}\nCreate basket now?`,
      [
        { id: "bk_do_create", title: "Create" },
        { id: "back_home", title: "Back to Menu" },
      ],
    );
    return new Response("ok");
  }

  // ---------- Contribution Amount (UPGRADED to pending/approve pattern) ----------
  if (state === "await_contrib_amount") {
    const amount = parseInt(body.replace(/\D/g, ""), 10);
    if (!Number.isFinite(amount) || amount <= 0) {
      await sendButtons(from, "Enter a valid amount (RWF).", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }

    const baskId = data?.basket_id as string;
    const bask = await getBasket(baskId);
    if (!bask) {
      await clearState(user_id);
      await sendButtons(from, "Basket not found.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }

    // Create a pending contribution row (additive)
    let pending: ContributionRow | null = null;
    try {
      pending = await createPendingContribution(bask.id, user_id, amount);
    } catch (e) {
      console.error("createPendingContribution failed; falling back to legacy approve buttons", e);
    }

    // Notify the creator with NEW contrib_* buttons; fallback to legacy bk_appr_ flow if needed
    const { data: creator } = await sb.from("profiles").select("whatsapp_e164").eq("user_id", bask.creator_id).maybeSingle();
    const creatorWa = creator?.whatsapp_e164;

    if (creatorWa) {
      if (pending?.id) {
        // New interactive card
        await sendButtons(
          creatorWa,
          `Contribution review\nBasket: ${bask.name}\nFrom: ${from}\nAmount: RWF ${amount.toLocaleString()}`,
          [
            { id: `contrib_appr_${pending.id}`, title: "Approve" },
            { id: `contrib_rej_${pending.id}`, title: "Reject" },
            { id: `contrib_chat_${toWaDigits(from)}`, title: "Chat" },
          ],
        );
      } else {
        // Fallback to legacy approve buttons
        const cents = amount * 100;
        await sendButtons(
          creatorWa,
          `Contribution review:\nBasket: ${bask.name}\nFrom: ${from}\nAmount: RWF ${amount.toLocaleString()}`,
          [
            { id: `bk_appr_${bask.id}_${user_id}_${cents}`, title: "Approve" },
            { id: `bk_rej_${bask.id}_${user_id}_${cents}`, title: "Reject" },
          ],
        );
      }
    }

    await clearState(user_id);
    await sendButtons(from, "Sent to creator for approval. Youâ€™ll be notified.", [
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }

  // ---------- MoMo QR inputs (existing) ----------
  if (state === "momoqr_await_number") {
    const normalized = normalizeMoMoNumberInput(body);
    if (!normalized) {
      await sendButtons(from, "Send your MoMo number (07â€¦).", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    await setState(user_id, "momoqr_await_amount", { kind: "number", momo_value: normalized });
    await sendButtons(from, "Reply with amount in RWF (numbers only), or tap Skip amount.", [
      { id: "mqr_amt_skip", title: "Skip amount" },
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }

  if (state === "momoqr_await_code") {
    const normalized = normalizeMoMoCodeInput(body);
    if (!normalized) {
      await sendButtons(from, "Send your MoMo code (4â€“9 digits).", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    await setState(user_id, "momoqr_await_amount", { kind: "code", momo_value: normalized });
    await sendButtons(from, "Reply with amount in RWF (numbers only), or tap Skip amount.", [
      { id: "mqr_amt_skip", title: "Skip amount" },
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }

  if (state === "momoqr_await_amount") {
    const rawAmt = body.replace(/\s/g, "");
    const amt = parseInt(rawAmt.replace(/\D/g, ""), 10);
    if (!Number.isFinite(amt) || amt <= 0) {
      await sendButtons(from, "Enter a valid amount (RWF) or tap Skip amount.", [
        { id: "mqr_amt_skip", title: "Skip amount" },
        { id: "back_home", title: "Back to Menu" },
      ]);
      return new Response("ok");
    }
    // Proceed to generate
    const kind = data?.kind as "number" | "code";
    const momo_value = String(data?.momo_value ?? "");
    await generateAndSendMomoQR({ to: from, user_id, kind, momo_value, amount: amt });
    await clearState(user_id);
    return new Response("ok");
  }

  // At home: ANY text brings menu
  if (state === "home") {
    await sendHome(from);
    return new Response("ok");
  }
}

// ------------------ CONTINUATION: BUTTON REPLIES (existing + additive) ------------------
if (msg.interactive?.type === "button_reply") {
  const bid = msg.interactive.button_reply.id || "";

  // Add business: catalog skip (existing)
  if (bid === "biz_catalog_skip" && state === "await_business_catalog") {
    await setState(user_id, "await_business_location", { ...data, catalog_url: null });
    await sendButtons(
      from,
      "Share your business location.\n\nTap âž• and share your current location.",
      [{ id: "back_home", title: "Back to Menu" }],
    );
    return new Response("ok");
  }

  // Basket final create (existing â€” weâ€™ll attach additive CTAs afterwards)
  if (bid === "bk_do_create" && state === "await_basket_confirm") {
    const { name, description, type, momo_target, momo_is_code } = data || {};
    try {
      const slug = "BK-" + crypto.randomUUID().slice(0, 6).toUpperCase();
      const ins = await sb
        .from("baskets")
        .insert({
          name,
          description,
          type,
          status: type === "public" ? "pending_review" : "approved",
          creator_id: user_id,
          public_slug: slug,
          momo_target: momo_target ?? null,
          momo_is_code: momo_is_code ?? null,
        })
        .select("*")
        .single();
      if (ins.error) throw ins.error;

      await addMember(ins.data.id, user_id);

      if (type === "public") {
        // Send both: legacy text and NEW review card
        await sendText(e164(BASKET_REVIEW_ADMIN), `Basket pending review:\n${name}\nCreator: ${from}\nSlug: ${slug}`);
        await sendPublicReviewCardToAdmin(ins.data, from);

        // Creator copy while waiting (additive preview with deeplink/QR)
        const token = ins.data.public_slug || ins.data.id;
        const link = basketDeepLink(token);
        await sendButtons(from, "Basket created and sent for review.\nMeanwhile you can preview/share:", [
          { id: `bkdl_share_${ins.data.id}`, title: "Share Basket (WhatsApp)" },
          { id: `bkdl_qr_${ins.data.id}`, title: "QR to Open (WhatsApp)" },
        ]);
        // Also include the link as plain text for convenience
        await sendText(from, `Preview link:\n${link}`);
      } else {
        // Private: immediate Share/QR CTAs (additive) + legacy "View this basket"
        await sendButtons(from, "âœ… Basket created! Share with others or show a QR to join.", [
          { id: `bkdl_share_${ins.data.id}`, title: "Share Basket (WhatsApp)" },
          { id: `bkdl_qr_${ins.data.id}`, title: "QR to Open (WhatsApp)" },
        ]);
        await sendButtons(from, "More actions:", [
          { id: `b_${ins.data.id}`, title: "View this basket" },
          { id: "back_home", title: "Back to Menu" },
        ]);
      }
    } catch (e) {
      console.error(e);
      await sendButtons(from, "Couldnâ€™t create basket.", [{ id: "back_home", title: "Back to Menu" }]);
    }
    await clearState(user_id);
    return new Response("ok");
  }

  // NEW â€” MoMo QR: skip amount / again (existing path enriched)
  if (bid === "mqr_amt_skip" && state === "momoqr_await_amount") {
    const kind = data?.kind as "number" | "code";
    const momo_value = String(data?.momo_value ?? "");
    await generateAndSendMomoQR({ to: from, user_id, kind, momo_value, amount: null });
    await clearState(user_id);
    return new Response("ok");
  }

  if (bid === "mqr_again") {
    await setState(user_id, "momoqr_start");
    const my07 = to07FromE164(from);
    await sendList(from, {
      title: "MoMo QR Code",
      body: "Generate a QR that opens your dialer with MoMo payment USSD.",
      sectionTitle: "Options",
      rows: [
        { id: "mqr_use_wa", title: "Use this number", description: `Your WhatsApp: ${my07 || "unknown"}` },
        { id: "mqr_enter_num", title: "Enter MoMo number", description: "07â€¦ mobile number" },
        { id: "mqr_enter_code", title: "Enter MoMo code", description: "4â€“9 digit code" },
      ],
    });
    return new Response("ok");
  }

  // NEW â€” Schedule: ask for optional drop-off after pickup is saved
  if (bid === "sched_add_drop" && state === "sched_post_pickup") {
    const trip_id = data?.trip_id as string | undefined;
    const role = data?.role as string | undefined;
    if (!trip_id) {
      await clearState(user_id);
      await sendButtons(from, "Trip context lost. Please schedule again.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    await setState(user_id, "sched_await_drop", { trip_id, role });
    await sendButtons(from, "Share your drop-off location.\n\nTap âž• and share your current location.", [
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }

  if (bid === "sched_skip_drop" && state === "sched_post_pickup") {
    // Go straight to matching
    const trip_id = data?.trip_id as string | undefined;
    const role = data?.role as "passenger" | "driver" | undefined;
    if (!trip_id || !role) {
      await clearState(user_id);
      await sendButtons(from, "Trip context lost. Please schedule again.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    try {
      if (role === "passenger") {
        const matches = await rpcMatchDriversForTripEx(trip_id, 10, true);
        if (matches?.length) {
          await setState(user_id, "await_match_select", { role, list: matches });
          await sendList(from, {
            title: "Matching Drivers",
            body: "Pick a driver to chat.",
            sectionTitle: "Drivers",
            rows: matches.slice(0, 10).map((m, i) => ({
              id: `mtch_${i}_${m.trip_id}`,
              title: safeRowTitle(`${fmtKm(m.distance_km)} â€¢ ${timeAgo(m.created_at)}`, 24),
            })),
          });
        } else {
          await sendButtons(from, "No immediate matches. Weâ€™ll keep looking.", [{ id: "back_home", title: "Back to Menu" }]);
        }
      } else {
        const matches = await rpcMatchPassengersForTripEx(trip_id, 10, true);
        if (matches?.length) {
          await setState(user_id, "await_match_select", { role, list: matches });
          await sendList(from, {
            title: "Matching Passengers",
            body: "Pick a passenger to chat.",
            sectionTitle: "Passengers",
            rows: matches.slice(0, 10).map((m, i) => ({
              id: `mtch_${i}_${m.trip_id}`,
              title: safeRowTitle(`${fmtKm(m.distance_km)} â€¢ ${timeAgo(m.created_at)}`, 24),
            })),
          });
        } else {
          await sendButtons(from, "No immediate matches. Weâ€™ll keep looking.", [{ id: "back_home", title: "Back to Menu" }]);
        }
      }
    } catch (e) {
      console.error("sched_skip_drop matching error", e);
      await sendButtons(from, "Couldnâ€™t fetch matches.", [{ id: "back_home", title: "Back to Menu" }]);
    }
    return new Response("ok");
  }
}

// ------------------ CONTINUATION: LOCATION HANDLING (existing + additive) ------------------
if (msg.type === "location") {
  const { latitude: lat, longitude: lon } = msg.location;

  // ---------- NEW: vehicle-first nearby drivers ----------
  if (state === "near_await_loc_drivers") {
    try {
      const veh = (data?.vehicle_type || "moto") as string;
      const rows = await rpcNearbyDriversByVehicle(lat, lon, from, veh, 10);
      if (!rows?.length) {
        await sendButtons(from, "No drivers nearby for that vehicle type.", [{ id: "back_home", title: "Back to Menu" }]);
        await clearState(user_id);
        return new Response("ok");
      }
      await setState(user_id, "near_await_loc_drivers", { lat, lon, vehicle_type: veh, drivers: rows });
      await sendList(from, {
        title: "Nearby Drivers",
        body: "Pick a driver to chat.",
        sectionTitle: "Drivers",
        rows: rows.slice(0, 10).map((d, i) => ({
          id: `drv_${i}`,
          title: safeRowTitle(`${fmtKm(d.distance_km)} â€¢ ${timeAgo(d.last_seen)}`, 24),
          description: d.whatsapp_e164 || "driver",
        })),
      });
    } catch (e) {
      console.error(e);
      await sendButtons(from, "Couldnâ€™t fetch drivers.", [{ id: "back_home", title: "Back to Menu" }]);
    }
    return new Response("ok");
  }

  // ---------- NEW: vehicle-first nearby passengers ----------
  if (state === "near_await_loc_passengers") {
    try {
      const veh = (data?.vehicle_type || "moto") as string;
      const rows = await rpcNearbyPassengersByVehicle(lat, lon, from, veh, 10);
      if (!rows?.length) {
        await sendButtons(from, "No passengers nearby for that vehicle type.", [{ id: "back_home", title: "Back to Menu" }]);
        await clearState(user_id);
        return new Response("ok");
      }
      await setState(user_id, "near_await_loc_passengers", { lat, lon, vehicle_type: veh, pax: rows });
      await sendList(from, {
        title: "Nearby Passengers",
        body: "Pick a passenger to chat.",
        sectionTitle: "Passengers",
        rows: rows.slice(0, 10).map((p, i) => ({
          id: `pax_${i}`,
          title: safeRowTitle(`${fmtKm(p.distance_km)} â€¢ ${timeAgo(p.created_at)}`, 24),
          description: `trip ${p.trip_id}`,
        })),
      });
    } catch (e) {
      console.error(e);
      await sendButtons(from, "Couldnâ€™t fetch passengers.", [{ id: "back_home", title: "Back to Menu" }]);
    }
    return new Response("ok");
  }

  // ---------- Marketplace business location (existing; kept) ----------
  if (state === "await_business_location") {
    const st2 = await getState(user_id);
    try {
      await sb.from("businesses").insert({
        owner_whatsapp: from,
        category_id: st2.data.category_id,
        name: st2.data.name,
        description: st2.data.description || "",
        catalog_url: st2.data.catalog_url || null,
        geo: `SRID=4326;POINT(${lon} ${lat})`,
        is_active: true,
      });
      await sendButtons(from, "âœ… Business listed! People nearby can discover it in Marketplace.", [
        { id: "back_home", title: "Back to Menu" },
      ]);
    } catch (e) {
      console.error(e);
      await sendButtons(from, "Couldnâ€™t save your business. Try again.", [
        { id: "back_home", title: "Back to Menu" },
      ]);
    }
    await clearState(user_id);
    return new Response("ok");
  }

  if (state === "await_market_see_loc") {
    const st2 = await getState(user_id);
    const catId = st2?.data?.category_id as number | undefined;
    try {
      const rows = await rpcNearbyBusinesses(lat, lon, from, 20);
      let filtered = rows;

      if (catId) {
        const ids = rows.map((r) => r.id);
        if (ids.length) {
          const { data: meta } = await sb.from("businesses").select("id,category_id").in("id", ids);
          const idToCat = new Map(meta?.map((m) => [m.id, m.category_id]) || []);
          filtered = rows.filter((r) => idToCat.get(r.id) === catId);
        }
      }

      if (!filtered?.length) {
        await sendButtons(from, "No businesses found nearby for that category.", [
          { id: "back_home", title: "Back to Menu" },
        ]);
        await clearState(user_id);
        return new Response("ok");
      }
      await setState(user_id, "await_market_see_loc", {
        ...st2.data,
        lat,
        lon,
        results: filtered,
      });
      await sendList(from, {
        title: "Nearby Businesses",
        body: "Pick a business for actions.",
        sectionTitle: "Businesses",
        rows: filtered.slice(0, 10).map((b, i) => ({
          id: `biz_${i}_${b.id}`,
          title: safeRowTitle(b.name, 24),
          description: safeRowDesc(`${fmtKm(b.distance_km)} â€¢ ${(b.description || "").slice(0, 48)}`, 72),
        })),
      });
    } catch (e) {
      console.error(e);
      await sendButtons(from, "Couldnâ€™t fetch businesses.", [{ id: "back_home", title: "Back to Menu" }]);
    }
    return new Response("ok");
  }

  // ---------- Schedule pickup (existing save) + ADD: ask for optional drop-off ----------
  if (state === "await_schedule_pickup") {
    const st2 = await getState(user_id);
    const role = st2.data.role as "passenger" | "driver";
    const vehicle_type = st2.data.vehicle_type as string;
    try {
      const ins = await sb.from("trips").insert({
        creator_user_id: user_id,
        role,
        vehicle_type,
        pickup: `SRID=4326;POINT(${lon} ${lat})`,
        status: "open",
      }).select("id").single();

      if (ins.error) throw ins.error;
      const newTripId = ins.data.id as string;

      // Persist a transient state to handle the drop-off choice
      await setState(user_id, "sched_post_pickup", { trip_id: newTripId, role, vehicle_type });

      // Ask whether to add a drop-off (additive)
      await sendButtons(from, "âœ… Trip saved.\nAdd a drop-off location? It helps find better matches.", [
        { id: "sched_add_drop", title: "Add Drop-off" },
        { id: "sched_skip_drop", title: "Skip" },
      ]);

      // (Weâ€™ll only fetch/send matches after the user chooses add/skip and we either get dropoff or skip.)
    } catch (e) {
      console.error(e);
      await sendButtons(from, "Couldnâ€™t save your trip.", [{ id: "back_home", title: "Back to Menu" }]);
      await clearState(user_id);
    }
    return new Response("ok");
  }

  // ---------- NEW: Schedule drop-off capture ----------
  if (state === "sched_await_drop") {
    const trip_id = data?.trip_id as string | undefined;
    const role = data?.role as "passenger" | "driver" | undefined;
    if (!trip_id || !role) {
      await clearState(user_id);
      await sendButtons(from, "Trip context lost. Please schedule again.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    try {
      await updateTripDropoff(trip_id, lon, lat);
    } catch (_e) {}

    // Now fetch matches with preferDropoff scoring
    try {
      if (role === "passenger") {
        const matches = await rpcMatchDriversForTripEx(trip_id, 10, true);
        if (matches?.length) {
          await setState(user_id, "await_match_select", { role, list: matches });
          await sendList(from, {
            title: "Matching Drivers",
            body: "Pick a driver to chat.",
            sectionTitle: "Drivers",
            rows: matches.slice(0, 10).map((m, i) => ({
              id: `mtch_${i}_${m.trip_id}`,
              title: safeRowTitle(`${fmtKm(m.distance_km)} â€¢ ${timeAgo(m.created_at)}`, 24),
            })),
          });
        } else {
          await sendButtons(from, "No immediate matches. Weâ€™ll keep looking.", [{ id: "back_home", title: "Back to Menu" }]);
        }
      } else {
        const matches = await rpcMatchPassengersForTripEx(trip_id, 10, true);
        if (matches?.length) {
          await setState(user_id, "await_match_select", { role, list: matches });
          await sendList(from, {
            title: "Matching Passengers",
            body: "Pick a passenger to chat.",
            sectionTitle: "Passengers",
            rows: matches.slice(0, 10).map((m, i) => ({
              id: `mtch_${i}_${m.trip_id}`,
              title: safeRowTitle(`${fmtKm(m.distance_km)} â€¢ ${timeAgo(m.created_at)}`, 24),
            })),
          });
        } else {
          await sendButtons(from, "No immediate matches. Weâ€™ll keep looking.", [{ id: "back_home", title: "Back to Menu" }]);
        }
      }
    } catch (e) {
      console.error("sched_await_drop matching error", e);
      await sendButtons(from, "Couldnâ€™t fetch matches.", [{ id: "back_home", title: "Back to Menu" }]);
    }
    return new Response("ok");
  }
}

// ------------------ CONTINUATION: ROW-CLICKS (existing + additive ensured) ------------------
if (msg.interactive?.type === "list_reply") {
  const id = msg.interactive.list_reply.id;

  // Nearby drivers â†’ chat (works for both legacy await_loc_drivers and new near_await_loc_drivers)
  if (id.startsWith("drv_")) {
    const st2 = await getState(user_id);
    const arr = (st2?.data?.drivers || []);
    const idx = parseInt(id.split("_")[1]);
    const chosen = arr[idx];
    if (!chosen) {
      await sendButtons(from, "That driver is no longer available.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    const wa = chosen.whatsapp_e164 ? e164(chosen.whatsapp_e164) : null;
    if (!wa) {
      await sendButtons(from, "No contact for this driver.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    await markServedDriver(from, String(chosen.driver_user_id));
    await clearState(user_id);
    await sendButtons(from, `Chat with driver:\nhttps://wa.me/${wa.replace("+", "")}`, [
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }

  // Nearby passengers â†’ chat (works for both legacy and new)
  if (id.startsWith("pax_")) {
    const st2 = await getState(user_id);
    const arr = st2?.data?.pax || [];
    const idx = parseInt(id.split("_")[1]);
    const chosen = arr[idx];
    if (!chosen) {
      await sendButtons(from, "That passenger is no longer available.", [
        { id: "back_home", title: "Back to Menu" },
      ]);
      return new Response("ok");
    }
    let wa = chosen.whatsapp_e164;
    if (!wa && chosen.creator_user_id) {
      const p = await sb
        .from("profiles")
        .select("whatsapp_e164")
        .eq("user_id", chosen.creator_user_id)
        .maybeSingle();
      wa = p.data?.whatsapp_e164;
    }
    if (!wa) {
      await sendButtons(from, "No contact for this passenger.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    await markServedPassenger(from, String(chosen.trip_id));
    await clearState(user_id);
    await sendButtons(from, `Chat with passenger:\nhttps://wa.me/${wa.replace("+", "")}`, [
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }

  // Businesses â†’ actions (existing; kept)
  if (id.startsWith("biz_")) {
    const st2 = await getState(user_id);
    const arr = st2?.data?.results || [];
    const idx = parseInt(id.split("_")[1]);
    const chosen = arr[idx];
    if (!chosen) {
      await sendButtons(from, "Business not available.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    const biz = await sb
      .from("businesses")
      .select("owner_whatsapp,catalog_url,name,id")
      .eq("id", chosen.id)
      .maybeSingle();
    if (!biz.data) {
      await sendButtons(from, "Business not available.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    const { owner_whatsapp, catalog_url, name, id: realId } = biz.data;
    const btns: Array<{ id: string; title: string }> = [];
    if (catalog_url) btns.push({ id: `biz_catalog_${realId}`, title: "View Catalog" });
    if (owner_whatsapp) btns.push({ id: `biz_contact_${realId}`, title: "Contact" });
    if (!btns.length) btns.push({ id: "back_home", title: "Back to Menu" });
    await sendButtons(from, `Actions for ${name}`, btns.slice(0, 3));
    return new Response("ok");
  }

  // Baskets â†’ open actions menu (existing; augmented rows now include bkdl_* too)
  if (id.startsWith("b_")) {
    const basketId = id.slice(2);
    const b = await getBasket(basketId);
    if (!b) {
      await sendButtons(from, "Basket not available.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    const isCreator = b.creator_id === user_id;
    const memberNow = await isMember(basketId, user_id);
    await setState(user_id, "basket_ctx", { basket_id: basketId });
    await sendList(from, {
      title: safeRowTitle(b.name, 60),
      body: "Choose an action.",
      sectionTitle: "Actions",
      rows: basketActionsRows(b, isCreator, memberNow),
    });
    return new Response("ok");
  }

  // Basket actions & paging (existing; add-safe)
  if (id.startsWith("bk_")) {
    const st2 = await getState(user_id);
    const basketId = (st2?.data?.basket_id) || id.split("_")[2];
    const b = await getBasket(basketId);
    if (!b) {
      await sendButtons(from, "Basket not available.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    const isCreator = b.creator_id === user_id;

    if (id.startsWith("bk_det_")) {
      await sendButtons(from, basketDetailsText(b), [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }

    if (id.startsWith("bk_share_")) {
      const token = b.public_slug || b.id;
      await sendButtons(from, `Share this token:\nJOIN_BASKET:${token}`, [
        { id: "back_home", title: "Back to Menu" },
      ]);
      return new Response("ok");
    }

    if (id.startsWith("bk_qr_")) {
      const token = b.public_slug || b.id;
      const url = qrUrlForJoin(token);
      await sendImageUrl(from, url, `Scan to join: ${b.name}`);
      return new Response("ok");
    }

    if (id.startsWith("bk_join_")) {
      await addMember(b.id, user_id);
      try {
        const { data: creator } = await sb.from("profiles").select("whatsapp_e164").eq("user_id", b.creator_id).maybeSingle();
        if (creator?.whatsapp_e164) {
          await sendText(creator.whatsapp_e164, `New member joined your basket: ${from} (${b.name})`);
        }
      } catch (_e) {}
      await sendButtons(from, "Joined âœ…", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }

    if (id.startsWith("bk_leave_")) {
      if (isCreator) {
        await sendButtons(from, "Creator cannot leave. Close the basket instead.", [
          { id: "back_home", title: "Back to Menu" },
        ]);
        return new Response("ok");
      }
      await removeMember(b.id, user_id);
      await sendButtons(from, "You left the basket.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }

    if (id.startsWith("bk_close_")) {
      if (!isCreator) {
        await sendButtons(from, "Only the creator can close this basket.", [{ id: "back_home", title: "Back to Menu" }]);
        return new Response("ok");
      }
      try {
        await sb.from("baskets").update({ status: "closed" }).eq("id", b.id);
        await sendButtons(from, "Basket closed.", [{ id: "back_home", title: "Back to Menu" }]);
      } catch (e) {
        console.error(e);
        await sendButtons(from, "Couldnâ€™t close the basket.", [{ id: "back_home", title: "Back to Menu" }]);
      }
      return new Response("ok");
    }

    if (id.startsWith("bk_cont_")) {
      if (b.momo_target) {
        const ussd = buildMomoUssd(b.momo_target, !!b.momo_is_code);
        await sendButtons(from, `Tap to dial USSD:\n${ussd}`, [
          { id: "back_home", title: "Back to Menu" },
        ]);
      } else {
        await sendButtons(from, "Creator didnâ€™t set MoMo yet.", [{ id: "back_home", title: "Back to Menu" }]);
      }
      await setState(user_id, "await_contrib_amount", { basket_id: b.id });
      await sendButtons(from, "Reply with the amount you sent (numbers only).", [
        { id: "back_home", title: "Back to Menu" },
      ]);
      return new Response("ok");
    }

    if (id.startsWith("bk_mems_")) {
      const parts = id.split("_");
      const page = parseInt(parts[3] || "0", 10);
      const members = await listMembersPage(b.id, page, 9);
      if (!members.length) {
        await sendButtons(from, "No more members.", [{ id: "back_home", title: "Back to Menu" }]);
        return new Response("ok");
      }
      const rows = members.map((m, i) => ({
        id: `bk_mem_${m.user_id}`,
        title: safeRowTitle(`#${(page * 9) + (i + 1)} â€¢ ${m.code}`, 24),
        description: `RWF ${m.total_contributed?.toLocaleString?.() ?? m.total_contributed}`,
      }));
      rows.push({ id: `bk_mems_${b.id}_${page + 1}`, title: "Next page â†’" });
      await setState(user_id, "basket_ctx", { basket_id: b.id, page });
      await sendList(from, {
        title: safeRowTitle(`${b.name} â€” Members`, 60),
        body: "Ranked by total contributed",
        sectionTitle: `Page ${page + 1}`,
        rows,
      });
      return new Response("ok");
    }
  }

  // Trip matches selection (existing; kept)
  if (id.startsWith("mtch_")) {
    const st2 = await getState(user_id);
    const list = st2?.data?.list || [];
    const idx = parseInt(id.split("_")[1], 10);
    const tripRow = list[idx];
    if (!tripRow) {
      await sendButtons(from, "No longer available.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    const { data: prof } = await sb
      .from("profiles")
      .select("whatsapp_e164")
      .eq("user_id", tripRow.creator_user_id)
      .maybeSingle();
    const wa = prof?.whatsapp_e164;
    if (!wa) {
      await sendButtons(from, "No contact found.", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    await clearState(user_id);
    await sendButtons(from, `Chat:\nhttps://wa.me/${wa.replace("+", "")}`, [
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }

  // NEW: MoMo QR sub-options (list) â€” handled in PART 1 but keep here for idempotency
  if (id === "mqr_use_wa" || id === "mqr_enter_num" || id === "mqr_enter_code") {
    if (id === "mqr_use_wa") {
      const my07 = to07FromE164(from);
      if (!/^07\d{8}$/.test(my07)) {
        await sendButtons(from, "Your WhatsApp number isnâ€™t +2507â€¦ â€” please enter a MoMo number instead.", [
          { id: "back_home", title: "Back to Menu" },
        ]);
        return new Response("ok");
      }
      await setState(user_id, "momoqr_await_amount", { kind: "number", momo_value: my07 });
      await sendButtons(from, "Reply with amount in RWF (numbers only), or tap Skip amount.", [
        { id: "mqr_amt_skip", title: "Skip amount" },
        { id: "back_home", title: "Back to Menu" },
      ]);
      return new Response("ok");
    }
    if (id === "mqr_enter_num") {
      await setState(user_id, "momoqr_await_number");
      await sendButtons(from, "Send your MoMo number (07â€¦).", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
    if (id === "mqr_enter_code") {
      await setState(user_id, "momoqr_await_code");
      await sendButtons(from, "Send your MoMo code (4â€“9 digits).", [{ id: "back_home", title: "Back to Menu" }]);
      return new Response("ok");
    }
  }
}

// ------------------ INSURANCE MEDIA (existing; kept) ------------------
const stAfter = await getState(user_id);
state = stAfter.key;
data = stAfter.data || {};
if (state === "ins_wait_doc" && (msg.type === "image" || msg.type === "document")) {
  const mediaId = msg.image?.id || msg.document?.id;
  if (!mediaId) {
    await sendButtons(from, "Please send a photo or PDF (one file only).\n\nTap âž• and upload your file.", [
      { id: "back_home", title: "Back to Menu" },
    ]);
    return new Response("ok");
  }
  try {
    const leadIns = await sb.from("insurance_leads").insert({ whatsapp: from }).select("id").single();
    if (leadIns.error) throw leadIns.error;
    const leadId = leadIns.data.id as string;

    const bin = await fetchWAMedia(mediaId);
    const path = `insurance/${leadId}/${crypto.randomUUID()}.${extOf(bin.mime)}`;
    const up = await sb.storage.from("insurance").upload(path, bin.bytes, {
      contentType: bin.mime,
      upsert: false,
    });
    if (up.error) throw up.error;

    try {
      await sb.from("insurance_media").insert({
        lead_id: leadId,
        wa_media_id: mediaId,
        storage_path: path,
        mime_type: bin.mime,
      });
    } catch (_e) {}

    const signed = await sb.storage.from("insurance").createSignedUrl(path, 600);
    const ocr = await runInsuranceOCR(signed.data?.signedUrl || "");
    const ex = normIns(ocr.extracted || {});

    await sb.from("insurance_leads").update({
      file_path: path,
      raw_ocr: ocr.raw,
      extracted: ex,
    }).eq("id", leadId);

    await sendButtons(from, insUserSummary(ex) + "\n\nOur team will contact you shortly.", [
      { id: "back_home", title: "Back to Menu" },
    ]);

    const cfg = await getConfig();
    const admins = [
      ...(cfg.insurance_admin_numbers || []),
      ...EXTRA_INSURANCE_ADMINS,
    ].map(e164);
    for (const a of Array.from(new Set(admins))) {
      await sendText(a, insAdminSummary(from, ex));
    }
  } catch (err) {
    console.error(err);
    await sendButtons(
      from,
      "We couldnâ€™t read the file. Please send a clear photo or PDF (one file only).\n\nTap âž• and upload your file.",
      [{ id: "back_home", title: "Back to Menu" }],
    );
  }
  await clearState(user_id);
  return new Response("ok");
}

// ------------------ FINAL FALLBACK (existing; kept) ------------------
if (state === "home") {
  await sendHome(from);
  return new Response("ok");
}

await sendButtons(from, "I didnâ€™t get that. Please choose an option.", [
  { id: "back_home", title: "Back to Menu" },
]);
return new Response("ok");
});

// ------------------ BOTTOM HELPERS (continued) ------------------

/** Generate & send MoMo QR (image + dial/share text + buttons), with logging */
async function generateAndSendMomoQR(args: {
  to: string;
  user_id: string;
  kind: "number" | "code";
  momo_value: string;
  amount: number | null;
}) {
  const { to, user_id, kind, momo_value, amount } = args;
  const amt = (amount && amount > 0) ? Math.floor(amount) : null;
  const { ussd, tel } = buildUssdFor(kind, momo_value, amt);
  const qr = qrUrlForUssdTel(tel, 768);

  const footer = kind === "number" ? `Number: ${momo_value}` : `Code: ${momo_value}`;
  await sendImageUrl(to, qr, `Scan to pay\n${footer}`);

  const shareLink = tel; // keeping tel: link as share handle
  const lines = [
    `USSD: ${ussd}`,
    `Tap to dial: ${tel}`,
    `Share: ${shareLink}`,
  ];
  await sendText(to, lines.join("\n"));

  await sendButtons(to, "Do you want to generate another one?", [
    { id: "mqr_again", title: "Generate another" },
    { id: "back_home", title: "Back to Menu" },
  ]);

  await logMomoQrRequest({
    user_id,
    whatsapp_e164: to,
    kind,
    momo_value,
    amount_rwf: amt ?? null,
    ussd_text: ussd,
    tel_uri: tel,
    qr_url: qr,
    share_url: shareLink,
  });
}

/* =========================
   >>> PART 3/3 will finalize:
   - Extra small helpers (no-op placeholders for future RPC defaults)
   - SQL migration hints (commented) for additive schema
   - End-of-file export (no-op, for Deno)
   ========================= */
/* =========================
   wa-webhook.ts â€” PART 3/3
   (Append this immediately after PART 2/3. Donâ€™t remove anything.)
   ========================= */

/* deno-lint-ignore-file no-explicit-any */

// -----------------------------------------------------------------------------
// Additive-only helpers, RPC wrappers, and small utilities referenced earlier.
// -----------------------------------------------------------------------------

/** Strip and return only E.164 digits (no +). */
function toWaDigits(e164like: string): string {
  const s = e164(e164like);
  return s.replace(/\D/g, "");
}

/** Get the public WhatsApp number for deeplinks. Prefers ENV.WA_BOT_NUMBER_E164. */
function getBotNumberDigits(): string {
  const envBot = (Deno.env.get("WA_BOT_NUMBER_E164") || "").trim();
  if (envBot) return toWaDigits(envBot);
  // Fallback: try to read from profiles table (optional) or use WA_PHONE_ID (not ideal).
  // Since we cannot perform an external lookup here, we fallback to digits of `from` at send-time if needed.
  // As a safer default, return empty string and let callers handle.
  return "";
}

/** Build a WhatsApp deeplink to our bot with JOIN_BASKET:<token> prefilled. */
function basketDeepLink(token: string): string {
  const digits = getBotNumberDigits();
  const base = digits ? `https://wa.me/${digits}` : `https://wa.me/`;
  const text = encodeURIComponent(`JOIN_BASKET:${token}`);
  return `${base}?text=${text}`;
}

/** QR URL that encodes any deeplink URL (for QuickChart). */
function qrUrlForDeepLink(url: string, size = 512): string {
  return `https://quickchart.io/qr?text=${encodeURIComponent(url)}&margin=1&size=${size}`;
}

// -----------------------------------------------------------------------------
// Nearby â€” vehicle-aware RPC wrappers (additive)
// -----------------------------------------------------------------------------

/** NEW RPC: nearby_drivers_by_vehicle */
async function rpcNearbyDriversByVehicle(
  lat: number,
  lon: number,
  viewer: string,
  vehicle: string,
  limit = 10,
) {
  // Prefer the new RPC if present, else fallback to generic and filter.
  try {
    const { data, error } = await sb.rpc("nearby_drivers_by_vehicle", {
      _lat: lat,
      _lon: lon,
      _viewer: viewer,
      _vehicle: vehicle,
      _limit: limit,
    });
    if (error) throw error;
    return data as Array<{
      driver_user_id: string;
      whatsapp_e164: string | null;
      distance_km: number;
      last_seen: string;
      vehicle_type?: string | null;
    }>;
  } catch (_rpcMissing) {
    // Fallback: call generic and then best-effort filter by driver/user vehicle type if joinable
    const base = await rpcNearbyDrivers(lat, lon, viewer, limit * 2);
    if (!base?.length) return base;
    const ids = base.map((b) => b.driver_user_id);
    try {
      const { data: metas } = await sb
        .from("drivers")
        .select("user_id,vehicle_type")
        .in("user_id", ids);
      const map = new Map((metas || []).map((m) => [m.user_id, (m as any).vehicle_type]));
      const filtered = base.filter((b) => {
        const vt = (map.get(b.driver_user_id) || "").toString();
        return !vehicle || vt === vehicle;
      });
      return filtered.slice(0, limit);
    } catch {
      return base.slice(0, limit);
    }
  }
}

/** NEW RPC: nearby_passengers_by_vehicle */
async function rpcNearbyPassengersByVehicle(
  lat: number,
  lon: number,
  viewer: string,
  vehicle: string,
  limit = 10,
) {
  try {
    const { data, error } = await sb.rpc("nearby_passengers_by_vehicle", {
      _lat: lat,
      _lon: lon,
      _viewer: viewer,
      _vehicle: vehicle,
      _limit: limit,
    });
    if (error) throw error;
    return data as Array<{
      trip_id: string;
      creator_user_id: string;
      whatsapp_e164: string | null;
      distance_km: number;
      created_at: string;
      vehicle_type?: string | null;
    }>;
  } catch (_rpcMissing) {
    // Fallback: call generic and filter by trip vehicle_type via join
    const base = await rpcNearbyPassengers(lat, lon, viewer, limit * 2);
    if (!base?.length) return base;
    const tripIds = base.map((t) => t.trip_id);
    try {
      const { data: trips } = await sb
        .from("trips")
        .select("id,vehicle_type")
        .in("id", tripIds);
      const map = new Map((trips || []).map((t) => [t.id, (t as any).vehicle_type]));
      const filtered = base.filter((t) => {
        const vt = (map.get(t.trip_id) || "").toString();
        return !vehicle || vt === vehicle;
      });
      return filtered.slice(0, limit);
    } catch {
      return base.slice(0, limit);
    }
  }
}

// -----------------------------------------------------------------------------
// Schedule â€” extend match RPCs with optional drop-off preference (additive)
// -----------------------------------------------------------------------------

/** Extended driver match with optional preferDropoff scoring. */
async function rpcMatchDriversForTripEx(
  tripId: string,
  limit = 10,
  preferDropoff = false,
) {
  try {
    const { data, error } = await sb.rpc("match_drivers_for_trip", {
      _trip_id: tripId,
      _limit: limit,
      _prefer_dropoff: preferDropoff,
    });
    if (error) throw error;
    return data as Array<{ trip_id: string; creator_user_id: string; distance_km: number; created_at: string }>;
  } catch (_rpcMissing) {
    // Fallback: call legacy signature ignoring preferDropoff
    return rpcMatchDriversForTrip(tripId, limit);
  }
}

/** Extended passenger match with optional preferDropoff scoring. */
async function rpcMatchPassengersForTripEx(
  tripId: string,
  limit = 10,
  preferDropoff = false,
) {
  try {
    const { data, error } = await sb.rpc("match_passengers_for_trip", {
      _trip_id: tripId,
      _limit: limit,
      _prefer_dropoff: preferDropoff,
    });
    if (error) throw error;
    return data as Array<{ trip_id: string; creator_user_id: string; distance_km: number; created_at: string }>;
  } catch (_rpcMissing) {
    // Fallback: call legacy signature ignoring preferDropoff
    return rpcMatchPassengersForTrip(tripId, limit);
  }
}

/** Update a trip with a dropoff point (geometry Point, SRID 4326). */
async function updateTripDropoff(tripId: string, lon: number, lat: number) {
  await sb.from("trips").update({
    dropoff: `SRID=4326;POINT(${lon} ${lat})`,
  }).eq("id", tripId);
}

// -----------------------------------------------------------------------------
// Contributions â€” pending/approved data model helpers (additive)
// -----------------------------------------------------------------------------

type ContributionStatus = "pending" | "approved" | "rejected";
type ContributionRow = {
  id: string;
  basket_id: string;
  contributor_user_id: string;
  amount_rwf: number;
  status: ContributionStatus;
  created_at: string;
  approved_at: string | null;
  approver_user_id: string | null;
  wa_message_id?: string | null;
};

/** Create a pending contribution row. */
async function createPendingContribution(
  basketId: string,
  contributorUserId: string,
  amountRwf: number,
): Promise<ContributionRow> {
  const ins = await sb
    .from("basket_contributions")
    .insert({
      basket_id: basketId,
      contributor_user_id: contributorUserId,
      amount_rwf: Math.floor(amountRwf),
      status: "pending",
      created_at: new Date().toISOString(),
    })
    .select("*")
    .single();
  if (ins.error) throw ins.error;
  return ins.data as ContributionRow;
}

/** Approve a pending contribution: set status, stamp approved_at, update member total. */
async function approveContribution(
  contribId: string,
  approverUserId: string,
): Promise<ContributionRow | null> {
  // Fetch the row first
  const { data: row, error: err1 } = await sb
    .from("basket_contributions")
    .select("*")
    .eq("id", contribId)
    .maybeSingle();
  if (err1) throw err1;
  if (!row) return null;

  if (row.status === "approved") return row as ContributionRow; // idempotent
  if (row.status === "rejected") {
    // Cannot un-reject here; keep simple idempotency
    return row as ContributionRow;
  }

  // Mark approved
  const upd = await sb
    .from("basket_contributions")
    .update({
      status: "approved" as const,
      approved_at: new Date().toISOString(),
      approver_user_id: approverUserId,
    })
    .eq("id", contribId)
    .select("*")
    .single();
  if (upd.error) throw upd.error;

  // Increment basket_members.total_contributed
  await incrementMemberTotal(upd.data.basket_id, upd.data.contributor_user_id, upd.data.amount_rwf);

  return upd.data as ContributionRow;
}

/** Reject a pending contribution. */
async function rejectContribution(
  contribId: string,
  approverUserId: string,
): Promise<ContributionRow | null> {
  const { data: row, error: err1 } = await sb
    .from("basket_contributions")
    .select("*")
    .eq("id", contribId)
    .maybeSingle();
  if (err1) throw err1;
  if (!row) return null;
  if (row.status === "rejected") return row as ContributionRow; // idempotent
  if (row.status === "approved") return row as ContributionRow; // do nothing

  const upd = await sb
    .from("basket_contributions")
    .update({
      status: "rejected" as const,
      approved_at: null,
      approver_user_id: approverUserId,
    })
    .eq("id", contribId)
    .select("*")
    .single();
  if (upd.error) throw upd.error;
  return upd.data as ContributionRow;
}

/** Increment or initialize member total on approval. */
async function incrementMemberTotal(
  basketId: string,
  userId: string,
  amountRwf: number,
) {
  const { data: row } = await sb
    .from("basket_members")
    .select("total_contributed")
    .eq("basket_id", basketId)
    .eq("user_id", userId)
    .maybeSingle();
  const prev = row?.total_contributed ?? 0;
  await sb
    .from("basket_members")
    .upsert({
      basket_id: basketId,
      user_id: userId,
      total_contributed: Number(prev) + Math.floor(amountRwf),
      joined_at: new Date().toISOString(),
    });
}

/** Notify contributor of approval/rejection (best-effort). */
async function notifyContributorOutcome(contrib: ContributionRow) {
  try {
    const { data: prof } = await sb
      .from("profiles")
      .select("whatsapp_e164")
      .eq("user_id", contrib.contributor_user_id)
      .maybeSingle();
    const wa = prof?.whatsapp_e164;
    if (!wa) return;

    if (contrib.status === "approved") {
      await sendText(wa, `âœ… Contribution approved: RWF ${Number(contrib.amount_rwf).toLocaleString()}. Thank you!`);
    } else if (contrib.status === "rejected") {
      await sendText(wa, `âŒ Contribution rejected by the basket creator.`);
    }
  } catch (_e) {
    // ignore
  }
}

// -----------------------------------------------------------------------------
// Admin â€” public basket review card + handlers (IDs: pubrev_appr_*, pubrev_chat_*, pubrev_view_*)
// -----------------------------------------------------------------------------

/** Send an interactive review card to the admin for public basket. */
async function sendPublicReviewCardToAdmin(basketRow: any, creatorE164: string) {
  const name = basketRow?.name || "(unnamed)";
  const slug = basketRow?.public_slug || basketRow?.id || "";
  const body = `Basket review\nName: ${name}\nType: Public\nCreator: ${creatorE164}\nSlug: ${slug}`;
  const rows = [
    { id: `pubrev_appr_${basketRow.id}`, title: "Approve" },
    { id: `pubrev_chat_${toWaDigits(creatorE164)}`, title: "Chat creator" },
    { id: `pubrev_view_${basketRow.id}`, title: "View basket" },
  ];
  await sendButtons(e164(BASKET_REVIEW_ADMIN), body, rows);
}

/** Approve a public basket (status=approved). */
async function approvePublicBasket(basketId: string) {
  await sb.from("baskets").update({ status: "approved" }).eq("id", basketId);
}

/** Notify creator after basket approval with Share/QR buttons. */
async function notifyCreatorApproved(basketId: string) {
  const b = await getBasket(basketId);
  if (!b) return;
  const { data: prof } = await sb.from("profiles").select("whatsapp_e164").eq("user_id", b.creator_id).maybeSingle();
  const wa = prof?.whatsapp_e164;
  if (!wa) return;

  await sendButtons(wa, "âœ… Basket approved! Share it or get the QR below.", [
    { id: `bkdl_share_${b.id}`, title: "Share Basket (WhatsApp)" },
    { id: `bkdl_qr_${b.id}`, title: "QR to Open (WhatsApp)" },
  ]);
}

/** Build a QR for the deeplinked basket open. */
function basketDeepLinkQrUrl(basket: any): string {
  const token = basket.public_slug || basket.id;
  const link = basketDeepLink(token);
  return qrUrlForDeepLink(link, 512);
}

// -----------------------------------------------------------------------------
// Deep link share handlers (IDs: bkdl_share_<id>, bkdl_qr_<id>)
// -----------------------------------------------------------------------------

/** Handle Share Basket (WhatsApp) button for any user. */
async function handleBasketShareDeeplink(to: string, basketId: string) {
  const b = await getBasket(basketId);
  if (!b) {
    await sendButtons(to, "Basket not available.", [{ id: "back_home", title: "Back to Menu" }]);
    return;
  }
  const token = b.public_slug || b.id;
  const link = basketDeepLink(token);
  await sendText(to, `Share this WhatsApp link:\n${link}\nAnyone opening it will get basket options right away.`);
}

/** Handle QR to Open (WhatsApp) button for any user. */
async function handleBasketQrDeeplink(to: string, basketId: string) {
  const b = await getBasket(basketId);
  if (!b) {
    await sendButtons(to, "Basket not available.", [{ id: "back_home", title: "Back to Menu" }]);
    return;
  }
  const url = basketDeepLinkQrUrl(b);
  await sendImageUrl(to, url, `Scan to open basket: ${b.name}`);
}

// -----------------------------------------------------------------------------
// Vehicle-choice prompt helpers (optional use in future additive intercepts)
// -----------------------------------------------------------------------------

async function sendVehicleChoiceForDrivers(to: string) {
  await sendList(to, {
    title: "Nearby Drivers",
    body: "Which vehicle type do you want to see nearby?",
    sectionTitle: "Vehicle",
    rows: [
      { id: "near_v_drv_moto", title: "Moto" },
      { id: "near_v_drv_cab", title: "Cab" },
      { id: "near_v_drv_lifan", title: "Lifan" },
      { id: "near_v_drv_truck", title: "Truck" },
      { id: "near_v_drv_others", title: "Others" },
    ],
    buttonText: "Choose",
  });
}

async function sendVehicleChoiceForPassengers(to: string) {
  await sendList(to, {
    title: "Nearby Passengers",
    body: "Which vehicle type do you want to see nearby?",
    sectionTitle: "Vehicle",
    rows: [
      { id: "near_v_pax_moto", title: "Moto" },
      { id: "near_v_pax_cab", title: "Cab" },
      { id: "near_v_pax_lifan", title: "Lifan" },
      { id: "near_v_pax_truck", title: "Truck" },
      { id: "near_v_pax_others", title: "Others" },
    ],
    buttonText: "Choose",
  });
}

/** Map our near_v_* keys to canonical vehicle_type values used in DB. */
function mapNearVehicleIdToType(nearId: string): string {
  if (/_moto$/.test(nearId)) return "moto";
  if (/_cab$/.test(nearId)) return "cab";
  if (/_lifan$/.test(nearId)) return "lifan";
  if (/_truck$/.test(nearId)) return "truck";
  return "others";
}

// -----------------------------------------------------------------------------
// Basket type intercepts (fix for â€œBasket not availableâ€ on bk_type_* row clicks).
// NOTE: The main flow already emits bk_type_public/private; this helper is used
// by the early intercept code added in PART 1 (before generic bk_* row-clicks).
// -----------------------------------------------------------------------------

async function interceptBasketTypeSelection(
  userId: string,
  from: string,
  id: string,
) {
  const nextType = id === "bk_type_public" ? "public" : "private";
  const prev = await getState(userId);
  const baseData = prev?.data || {};
  await setState(userId, "await_basket_momo", { ...baseData, type: nextType });
  await sendButtons(from, "Send MoMo Number (07â€¦) or MoMo Code (4â€“9 digits).", [
    { id: "back_home", title: "Back to Menu" },
  ]);
}

// -----------------------------------------------------------------------------
// OPTIONAL: Nightly sanity RPC call stub (as a â€œno-opâ€ placeholder)
// -----------------------------------------------------------------------------

async function recomputeBasketTotalsIfPresent(basketId: string) {
  // If you later add a nightly job & RPC like `recompute_basket_totals(bid)`, call it here.
  // Keeping additive placeholder (no-op).
  try {
    // await sb.rpc("recompute_basket_totals", { _basket_id: basketId });
  } catch (_e) {}
}

// -----------------------------------------------------------------------------
// SQL migration hints (commented; to be applied via Supabase SQL editor/CLI)
// -----------------------------------------------------------------------------
/*
-- Add app_config column for bot number (nullable)
ALTER TABLE app_config ADD COLUMN IF NOT EXISTS wa_bot_number_e164 text;

-- Add trips.dropoff (nullable)
ALTER TABLE trips ADD COLUMN IF NOT EXISTS dropoff geometry(Point,4326);

-- New table: basket_contributions
CREATE TABLE IF NOT EXISTS basket_contributions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  basket_id uuid NOT NULL REFERENCES baskets(id) ON DELETE CASCADE,
  contributor_user_id uuid NOT NULL REFERENCES profiles(user_id) ON DELETE CASCADE,
  amount_rwf integer NOT NULL CHECK (amount_rwf > 0),
  status text NOT NULL CHECK (status IN ('pending','approved','rejected')),
  created_at timestamptz NOT NULL DEFAULT now(),
  approved_at timestamptz NULL,
  approver_user_id uuid NULL REFERENCES profiles(user_id),
  wa_message_id text NULL
);

-- Recommended index:
CREATE INDEX IF NOT EXISTS idx_basket_contrib_basket ON basket_contributions(basket_id);
CREATE INDEX IF NOT EXISTS idx_basket_contrib_contributor ON basket_contributions(contributor_user_id);
CREATE INDEX IF NOT EXISTS idx_basket_contrib_status ON basket_contributions(status);

-- Optional: baskets.audit JSONB
ALTER TABLE baskets ADD COLUMN IF NOT EXISTS audit jsonb NULL;

-- New/extended RPCs (sketch; implement in Postgres):
-- nearby_drivers_by_vehicle(_lat float8, _lon float8, _viewer text, _vehicle text, _limit int)
-- nearby_passengers_by_vehicle(_lat float8, _lon float8, _viewer text, _vehicle text, _limit int)
-- match_drivers_for_trip(_trip_id uuid, _limit int, _prefer_dropoff boolean default false)
-- match_passengers_for_trip(_trip_id uuid, _limit int, _prefer_dropoff boolean default false)

-- Keep legacy RPCs intact for zero breaking changes.
*/

// -----------------------------------------------------------------------------
// NO-OP export to satisfy Deno module boundary (file end).
// -----------------------------------------------------------------------------
export {};

