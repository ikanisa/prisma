--- test-results/supabase/schema-before.sql	2025-10-25 05:32:29.973959057 +0000
+++ test-results/supabase/schema-after.sql	2025-10-25 05:32:37.937848042 +0000
@@ -2,7 +2,7 @@
 -- PostgreSQL database dump
 --
 
-\restrict BSdxVS40cb7B1UvPKx3ezRa55oQf5Wi56dNeN9eaIeL9AfgipOKmmFr9CzPBMQd
+\restrict baXXsVCzNq08AJV2zVPJSoqiDNFoC8ytE3vk7pq4VS9heUc1aakiOrWM2bZzWsI
 
 -- Dumped from database version 16.10 (Ubuntu 16.10-0ubuntu0.24.04.1)
 -- Dumped by pg_dump version 16.10 (Ubuntu 16.10-0ubuntu0.24.04.1)
@@ -87,6 +87,188 @@
 ALTER TYPE public.role_level OWNER TO postgres;
 
 --
+-- Name: activity_log_enrich(); Type: FUNCTION; Schema: app; Owner: postgres
+--
+
+CREATE FUNCTION app.activity_log_enrich() RETURNS trigger
+    LANGUAGE plpgsql
+    SET search_path TO 'app', 'public'
+    AS $$
+DECLARE
+  catalog public.activity_event_catalog%ROWTYPE;
+BEGIN
+  SELECT * INTO catalog
+  FROM public.activity_event_catalog
+  WHERE action = NEW.action;
+
+  IF FOUND THEN
+    NEW.module := COALESCE(NEW.module, catalog.module);
+    NEW.policy_pack := COALESCE(NEW.policy_pack, catalog.policy_pack);
+    IF NEW.standard_refs IS NULL OR array_length(NEW.standard_refs, 1) = 0 THEN
+      NEW.standard_refs := catalog.standard_refs;
+    END IF;
+  END IF;
+
+  RETURN NEW;
+END;
+$$;
+
+
+ALTER FUNCTION app.activity_log_enrich() OWNER TO postgres;
+
+--
+-- Name: create_api_key(text, text, jsonb); Type: FUNCTION; Schema: app; Owner: postgres
+--
+
+CREATE FUNCTION app.create_api_key(p_org_slug text, p_name text, p_scope jsonb DEFAULT '{}'::jsonb) RETURNS TABLE(id uuid, key_plain text)
+    LANGUAGE plpgsql SECURITY DEFINER
+    SET search_path TO 'app', 'public'
+    AS $$
+declare
+  v_org uuid;
+  v_key bytea;
+  v_key_plain text;
+  v_hash text;
+begin
+  select id into v_org from organizations where slug = p_org_slug;
+  if v_org is null then
+    raise exception 'Unknown org slug %', p_org_slug;
+  end if;
+  if not app.is_org_admin(v_org) then
+    raise exception 'Forbidden';
+  end if;
+
+  v_key := gen_random_bytes(32);
+  v_key_plain := 'pk_' || encode(v_key, 'base64url');
+  v_hash := encode(digest(v_key_plain, 'sha256'), 'hex');
+
+  insert into api_keys(id, org_id, name, hashed_key, scope, created_by)
+  values (gen_random_uuid(), v_org, p_name, v_hash, coalesce(p_scope, '{}'::jsonb), app.current_user_id())
+  returning api_keys.id into id;
+
+  key_plain := v_key_plain;
+  return next;
+end;
+$$;
+
+
+ALTER FUNCTION app.create_api_key(p_org_slug text, p_name text, p_scope jsonb) OWNER TO postgres;
+
+--
+-- Name: current_user_id(); Type: FUNCTION; Schema: app; Owner: postgres
+--
+
+CREATE FUNCTION app.current_user_id() RETURNS uuid
+    LANGUAGE sql STABLE
+    SET search_path TO 'app', 'public'
+    AS $$
+  SELECT auth.uid();
+$$;
+
+
+ALTER FUNCTION app.current_user_id() OWNER TO postgres;
+
+--
+-- Name: is_member_of(uuid, text); Type: FUNCTION; Schema: app; Owner: postgres
+--
+
+CREATE FUNCTION app.is_member_of(p_org uuid, p_min_role text DEFAULT 'staff'::text) RETURNS boolean
+    LANGUAGE sql STABLE
+    SET search_path TO 'app', 'public'
+    AS $$
+  SELECT app.is_org_member(p_org, p_min_role::org_role);
+$$;
+
+
+ALTER FUNCTION app.is_member_of(p_org uuid, p_min_role text) OWNER TO postgres;
+
+--
+-- Name: is_org_admin(uuid); Type: FUNCTION; Schema: app; Owner: postgres
+--
+
+CREATE FUNCTION app.is_org_admin(p_org uuid) RETURNS boolean
+    LANGUAGE sql STABLE
+    SET search_path TO 'app', 'public'
+    AS $$
+  SELECT app.is_org_member(p_org, 'admin'::org_role);
+$$;
+
+
+ALTER FUNCTION app.is_org_admin(p_org uuid) OWNER TO postgres;
+
+--
+-- Name: is_org_member(uuid, public.org_role); Type: FUNCTION; Schema: app; Owner: postgres
+--
+
+CREATE FUNCTION app.is_org_member(p_org uuid, p_min_role public.org_role DEFAULT 'staff'::public.org_role) RETURNS boolean
+    LANGUAGE sql STABLE
+    SET search_path TO 'app', 'public'
+    AS $$
+  SELECT EXISTS (
+    SELECT 1 FROM members m
+    WHERE m.org_id = p_org
+      AND m.user_id = app.current_user_id()
+      AND app.role_rank(m.role) >= app.role_rank(p_min_role)
+  );
+$$;
+
+
+ALTER FUNCTION app.is_org_member(p_org uuid, p_min_role public.org_role) OWNER TO postgres;
+
+--
+-- Name: role_rank(public.org_role); Type: FUNCTION; Schema: app; Owner: postgres
+--
+
+CREATE FUNCTION app.role_rank(role_in public.org_role) RETURNS integer
+    LANGUAGE sql IMMUTABLE
+    SET search_path TO 'app', 'public'
+    AS $$
+  SELECT CASE role_in
+    WHEN 'admin' THEN 4
+    WHEN 'manager' THEN 3
+    WHEN 'staff' THEN 2
+    WHEN 'client' THEN 1
+    ELSE 0
+  END;
+$$;
+
+
+ALTER FUNCTION app.role_rank(role_in public.org_role) OWNER TO postgres;
+
+--
+-- Name: set_tenant(uuid); Type: FUNCTION; Schema: app; Owner: postgres
+--
+
+CREATE FUNCTION app.set_tenant(p_org uuid) RETURNS void
+    LANGUAGE plpgsql
+    SET search_path TO 'app', 'public'
+    AS $$
+begin
+  perform set_config('app.current_org', p_org::text, true);
+end;
+$$;
+
+
+ALTER FUNCTION app.set_tenant(p_org uuid) OWNER TO postgres;
+
+--
+-- Name: touch_updated_at(); Type: FUNCTION; Schema: app; Owner: postgres
+--
+
+CREATE FUNCTION app.touch_updated_at() RETURNS trigger
+    LANGUAGE plpgsql
+    SET search_path TO 'app', 'public'
+    AS $$
+BEGIN
+  NEW.updated_at = now();
+  RETURN NEW;
+END;
+$$;
+
+
+ALTER FUNCTION app.touch_updated_at() OWNER TO postgres;
+
+--
 -- Name: role(); Type: FUNCTION; Schema: auth; Owner: postgres
 --
 
@@ -108,6 +290,149 @@
 
 ALTER FUNCTION auth.uid() OWNER TO postgres;
 
+--
+-- Name: enforce_rate_limit(uuid, text, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
+--
+
+CREATE FUNCTION public.enforce_rate_limit(p_org_id uuid, p_resource text, p_limit integer, p_window_seconds integer) RETURNS TABLE(allowed boolean, request_count integer)
+    LANGUAGE plpgsql
+    SET search_path TO 'public'
+    AS $$
+declare
+  v_window_start timestamptz := date_trunc('second', now()) - make_interval(secs => mod(extract(epoch from now())::integer, p_window_seconds));
+  v_count integer;
+begin
+  insert into public.rate_limits(org_id, resource, window_start, request_count)
+  values (p_org_id, p_resource, v_window_start, 1)
+  on conflict (org_id, resource, window_start)
+  do update set request_count = public.rate_limits.request_count + 1
+  returning request_count into v_count;
+
+  return query select (v_count <= p_limit) as allowed, v_count;
+end;
+$$;
+
+
+ALTER FUNCTION public.enforce_rate_limit(p_org_id uuid, p_resource text, p_limit integer, p_window_seconds integer) OWNER TO postgres;
+
+--
+-- Name: handle_new_user(); Type: FUNCTION; Schema: public; Owner: postgres
+--
+
+CREATE FUNCTION public.handle_new_user() RETURNS trigger
+    LANGUAGE plpgsql SECURITY DEFINER
+    SET search_path TO 'public'
+    AS $$
+BEGIN
+  INSERT INTO public.users (id, email, name)
+  VALUES (
+    NEW.id,
+    NEW.email,
+    COALESCE(NEW.raw_user_meta_data->>'name', NEW.email)
+  );
+  RETURN NEW;
+END;
+$$;
+
+
+ALTER FUNCTION public.handle_new_user() OWNER TO postgres;
+
+--
+-- Name: handle_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
+--
+
+CREATE FUNCTION public.handle_updated_at() RETURNS trigger
+    LANGUAGE plpgsql
+    SET search_path TO 'public'
+    AS $$
+BEGIN
+  NEW.updated_at = now();
+  RETURN NEW;
+END;
+$$;
+
+
+ALTER FUNCTION public.handle_updated_at() OWNER TO postgres;
+
+--
+-- Name: has_min_role(uuid, public.role_level); Type: FUNCTION; Schema: public; Owner: postgres
+--
+
+CREATE FUNCTION public.has_min_role(org uuid, min public.role_level) RETURNS boolean
+    LANGUAGE sql STABLE SECURITY DEFINER
+    SET search_path TO 'public'
+    AS $$
+  WITH my_role AS (
+    SELECT m.role
+    FROM public.memberships m
+    WHERE m.org_id = org AND m.user_id = auth.uid()
+    LIMIT 1
+  )
+  SELECT COALESCE(
+    (SELECT CASE
+      WHEN (SELECT role FROM my_role) = 'SYSTEM_ADMIN' THEN true
+      WHEN (SELECT role FROM my_role) = 'MANAGER' AND min IN ('EMPLOYEE', 'MANAGER') THEN true
+      WHEN (SELECT role FROM my_role) = 'EMPLOYEE' AND min = 'EMPLOYEE' THEN true
+      ELSE false 
+    END),
+    false
+  );
+$$;
+
+
+ALTER FUNCTION public.has_min_role(org uuid, min public.role_level) OWNER TO postgres;
+
+--
+-- Name: is_member_of(uuid); Type: FUNCTION; Schema: public; Owner: postgres
+--
+
+CREATE FUNCTION public.is_member_of(org uuid) RETURNS boolean
+    LANGUAGE sql STABLE SECURITY DEFINER
+    SET search_path TO 'public'
+    AS $$
+  SELECT EXISTS (
+    SELECT 1 FROM public.memberships m
+    WHERE m.org_id = org AND m.user_id = auth.uid()
+  );
+$$;
+
+
+ALTER FUNCTION public.is_member_of(org uuid) OWNER TO postgres;
+
+--
+-- Name: set_notification_dispatch_queue_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
+--
+
+CREATE FUNCTION public.set_notification_dispatch_queue_updated_at() RETURNS trigger
+    LANGUAGE plpgsql
+    SET search_path TO 'public'
+    AS $$
+begin
+  new.updated_at = now();
+  return new;
+end;
+$$;
+
+
+ALTER FUNCTION public.set_notification_dispatch_queue_updated_at() OWNER TO postgres;
+
+--
+-- Name: set_user_notification_preferences_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
+--
+
+CREATE FUNCTION public.set_user_notification_preferences_updated_at() RETURNS trigger
+    LANGUAGE plpgsql
+    SET search_path TO 'public'
+    AS $$
+begin
+  new.updated_at = now();
+  return new;
+end;
+$$;
+
+
+ALTER FUNCTION public.set_user_notification_preferences_updated_at() OWNER TO postgres;
+
 SET default_tablespace = '';
 
 SET default_table_access_method = heap;
@@ -258,5 +583,5 @@
 -- PostgreSQL database dump complete
 --
 
-\unrestrict BSdxVS40cb7B1UvPKx3ezRa55oQf5Wi56dNeN9eaIeL9AfgipOKmmFr9CzPBMQd
+\unrestrict baXXsVCzNq08AJV2zVPJSoqiDNFoC8ytE3vk7pq4VS9heUc1aakiOrWM2bZzWsI
 
