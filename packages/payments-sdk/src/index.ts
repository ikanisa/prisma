import { createClient, PostgrestError } from '@supabase/supabase-js';

// Initialize via environment variables
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

/**
 * Generate a MoMo QR payment (RWF) and return QR URL, USSD string, and reference
 */
import { traced, tracedSync } from './tracing';

export async function createQr(
  user_id: string,
  amount: number,
  currency: string = 'RWF'
): Promise<{ qr_url: string; ussd_string: string; payment_ref: string }> {
  return traced('payments.createQr', async () => {
    const { data, error } = await supabase.rpc('create_momo_payment_link', {
      in_user_id: user_id,
      in_amount: amount,
      in_currency: currency
    });
    if (error) throw error;
    const { payment_ref, ussd_string } = (data as any)[0];
    const { data: row, error: selErr } = await supabase
      .from('payments')
      .select('qr_png_url')
      .eq('reference', payment_ref)
      .single();
    if (selErr) throw selErr;
    return { qr_url: row.qr_png_url!, ussd_string, payment_ref };
  });
}

/**
 * Preset payment shortcuts for common amounts
 */
export function payPreset(
  user_id: string,
  presetAmount: number
): Promise<{ qr_url: string; ussd_string: string; payment_ref: string }> {
  return traced('payments.payPreset', () => createQr(user_id, presetAmount));
}

/**
 * Placeholder for P2P payment flow (not implemented)
 */
export async function sendMoney(
  user_id: string,
  amount: number,
  recipient_phone: string
): Promise<{ transaction_id: string; status: string }> {
  return traced('payments.sendMoney', async () => {
  // Call the Postgres stored procedure that performs the peer-to-peer transfer.
  // The procedure is expected to
  //   1. create a payments row (or equivalent unified order/payment record)
  //   2. trigger the MoMo disbursement
  //   3. return the transaction reference and current status
  //
  // We purposefully keep all of the business logic inside the database layer so
  // that this SDK acts as a thin client-side wrapper.  This approach avoids
  // duplicating validation/business rules across multiple runtimes and keeps
  // network latency to an absolute minimum.

  const { data, error } = await supabase.rpc('send_momo_payment', {
    in_user_id: user_id,
    in_amount: amount,
    in_recipient_phone: recipient_phone
  });

  if (error) {
    // Surface a clean error object instead of the raw PostgREST error so that
    // calling code can reliably inspect the failure without depending on the
    // database driver internals.
    const err: PostgrestError = error;
    throw new Error(err.message ?? 'Failed to send money');
  }

  // The stored procedure returns a single-row record
  const result = (data as any)[0] ?? data;

  return {
    transaction_id: result?.transaction_id ?? result?.payment_ref ?? '',
    status: result?.status ?? 'unknown'
  };
  });
}

/**
 * Decode a scanned QR string that was previously generated by `createQr`.
 * Our QR payload format is currently a **fake** implementation so that the
 * full MoMo integration can be developed and tested offline.  The generator
 * (inside our Edge Functions layer) encodes the payment UUID by reversing
 * the characters and prefixing with `FAKE_QR::`.
 *
 * This helper reverses that process and returns the original payment_id so
 * that calling code (or other tools) can look-up the payment row.
 *
 * NOTE: Once the real production QR format is finalised this helper should be
 *       replaced with the official decoder provided by the payments team.
 */
export function processQrScan(
  params: { scanned_data: string }
): { payment_id: string } {
  return tracedSync('payments.processQrScan', () => {
  const { scanned_data } = params ?? ({} as any);

  if (typeof scanned_data !== 'string' || !scanned_data.length) {
    throw new Error('scanned_data must be a non-empty string');
  }

  const PREFIX = 'FAKE_QR::';
  if (!scanned_data.startsWith(PREFIX)) {
    throw new Error('Invalid QR data â€“ missing expected prefix');
  }

  // Remove the prefix and un-reverse the embedded id
  const reversedId = scanned_data.slice(PREFIX.length);
  const payment_id = [...reversedId].reverse().join('');

  // Very light UUID v4 format validation (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(payment_id)) {
    throw new Error('Invalid UUID format found inside QR data');
  }

  return { payment_id };
  });
}
